<!DOCTYPE html>
<html lang="es" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentación Push_Swap - Análisis Detallado</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* --- Design Tokens (CSS Variables) --- */
        :root {
            /* Dark Palette */
            --color-bg-primary: #0D1117;
            --color-bg-secondary: #161B22;
            --color-bg-tertiary: #21262D;
            --color-border-primary: #30363D;
            --color-border-secondary: #484F58;
            --color-text-primary: #e6edf3;
            --color-text-secondary: #bdc1c6;
            --color-text-tertiary: #8b949e;
            --color-accent-primary: #58a6ff;
            --color-accent-hover: #79c0ff;
            --color-accent-active: #388bfd;
            --color-accent-text: #ffffff;
            --color-success: #3fb950;
            --color-success-bg: rgba(63, 185, 80, 0.1);
            --color-error: #f85149;
            --color-error-bg: rgba(248, 81, 73, 0.1);
            --color-warning: #d29922; /* Yellow/Orange */
            --color-warning-bg: rgba(210, 153, 34, 0.1);
            --color-focus-ring: rgba(88, 166, 255, 0.5);

            /* Semantic Highlighting Colors */
            --color-highlight-function: #8be9fd;  /* Cyan */
            --color-highlight-struct: #ffb86c;   /* Orange */
            --color-highlight-type: #ffb86c;     /* Orange */
            --color-highlight-stack: #50fa7b;    /* Green */
            --color-highlight-field: #f1fa8c;    /* Yellow */
            --color-highlight-operation: #ff79c6;/* Pink */
            --color-highlight-constant: #bd93f9; /* Purple */
            --color-highlight-concept: var(--color-text-primary); /* White/Primary */
            --color-highlight-file: var(--color-text-tertiary); /* Grey */

            /* Typography */
            --font-family-sans: 'Inter', sans-serif;
            --font-family-mono: 'Courier New', Courier, monospace;

            /* Radii */
            --radius-sm: 0.25rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;

            /* Layout */
            --sidebar-width: 240px; /* Width of the sidebar */
        }

        /* --- Base Styles --- */
        html {
             scroll-behavior: smooth;
             scroll-padding-top: 5rem; /* Adjust scroll position to account for fixed header */
        }
        body {
            font-family: var(--font-family-sans);
            background-color: var(--color-bg-primary);
            color: var(--color-text-secondary);
            line-height: 1.65;
        }

        /* --- Headings --- */
        h1, h2, h3, h4, h5, h6 { color: var(--color-text-primary); font-weight: 600; line-height: 1.3; margin-bottom: 0.75em; }
        h1 { font-size: 2.5rem; font-weight: 700; margin-bottom: 1em; }
        h2 { font-size: 1.75rem; margin-top: 2.5rem; border-bottom: 1px solid var(--color-border-primary); padding-bottom: 0.4em; }
        h3 { font-size: 1.25rem; margin-top: 2rem; font-weight: 600; }
        h4 { font-size: 1.1rem; margin-top: 1.5rem; font-weight: 500; color: var(--color-text-primary); } /* Made H4 brighter */
        h5 { font-size: 1rem; margin-top: 1.25rem; font-weight: 600; color: var(--color-text-secondary); } /* Added H5 style */


        /* --- Paragraphs & Links --- */
        p { margin-bottom: 1.25rem; max-width: 75ch; }
        a { color: var(--color-accent-primary); text-decoration: none; transition: color 0.2s ease-in-out; }
        a:hover { color: var(--color-accent-hover); text-decoration: underline; }
        a strong { color: inherit; }

        /* --- Code Styling --- */
        pre { background-color: var(--color-bg-secondary); color: var(--color-text-primary); padding: 1.25rem; border-radius: var(--radius-md); overflow-x: auto; font-family: var(--font-family-mono); font-size: 0.9em; border: 1px solid var(--color-border-primary); line-height: 1.5; margin: 1.5rem 0; }
        code:not(pre code):not([class^="nombre-"]):not([class^="termino-"]):not([class^="concepto-"]) { font-family: var(--font-family-mono); background-color: var(--color-bg-tertiary); color: var(--color-text-primary); padding: 0.2em 0.4em; border-radius: var(--radius-sm); font-size: 0.875em; border: 1px solid var(--color-border-primary); vertical-align: middle; }
        strong { font-weight: 600; color: var(--color-text-primary); }

        /* --- Semantic Highlighting Classes --- */
        .nombre-funcion { color: var(--color-highlight-function); }
        .nombre-struct, .nombre-tipo { color: var(--color-highlight-struct); }
        .nombre-pila { color: var(--color-highlight-stack); font-weight: 600; }
        .nombre-campo { color: var(--color-highlight-field); }
        .nombre-operacion { color: var(--color-highlight-operation); }
        .nombre-constante { color: var(--color-highlight-constant); }
        .nombre-archivo { color: var(--color-highlight-file); font-style: italic; }
        .concepto-clave { color: var(--color-highlight-concept); font-weight: 600; font-family: var(--font-family-sans); }
        code[class^="nombre-"], code[class^="concepto-"] { background-color: transparent !important; border: none !important; padding: 0 !important; font-size: inherit !important; vertical-align: baseline !important; font-family: var(--font-family-mono); }
        code.nombre-pila, code.concepto-clave, code.nombre-archivo { font-family: var(--font-family-sans) !important; }

        /* --- Details/Summary Enhanced --- */
        details { background-color: var(--color-bg-secondary); border: 1px solid var(--color-border-primary); border-radius: var(--radius-md); margin-bottom: 1rem; /* Reduced bottom margin */ transition: background-color 0.2s ease; }
        details:hover { border-color: var(--color-border-secondary); }
        details > summary { cursor: pointer; list-style: none; padding: 0.8rem 1.2rem; /* Adjusted padding */ font-weight: 500; color: var(--color-text-primary); display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s ease; }
        details > summary:hover { background-color: var(--color-bg-tertiary); }
        details > summary::-webkit-details-marker { display: none; }
        details > summary::after { content: '\f078'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 0.8em; /* Smaller icon */ color: var(--color-text-tertiary); transition: transform 0.25s ease-in-out; margin-left: 0.5rem; }
        details[open] > summary { border-bottom: 1px solid var(--color-border-primary); }
        details[open] > summary::after { transform: rotate(180deg); }
        details > div { padding: 1.5rem; border-top: none; }
        /* Nested details styling */
        details details { margin-left: 1.5rem; margin-top: 0.5rem; border-left: 2px solid var(--color-border-secondary); border-radius: 0 var(--radius-md) var(--radius-md) 0; }
        details details > summary { padding: 0.6rem 1rem; font-size: 0.95em; }
        details details > div { padding: 1rem 1.5rem; }


        /* --- Content Sections --- */
        .content-section { margin-bottom: 3rem; padding: 2rem; background-color: var(--color-bg-secondary); border-radius: var(--radius-lg); border: 1px solid var(--color-border-primary); box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05), 0 2px 8px 0 rgba(0, 0, 0, 0.1); }
        .content-section ul ul, .content-section ol ol, .content-section ul ol, .content-section ol ul { margin-top: 0.75rem; margin-bottom: 0.75rem; }
        .content-section ul ul li::marker { content: '- '; color: var(--color-text-tertiary); }
        .content-section ul ul ul li::marker { content: '• '; color: var(--color-text-tertiary); }
        .content-section ol { list-style: decimal; margin-left: 1.5rem; }
        .content-section ol li { padding-left: 0.5rem; margin-bottom: 0.75rem; }
        /* Styling for function analysis */
        .function-analysis {
            margin-bottom: 1.5rem; /* Reduced margin */
            padding-bottom: 1rem; /* Reduced padding */
            /* Removed bottom border for nested details */
        }
        .function-analysis:last-child {
             padding-bottom: 0;
        }
        .function-analysis h5 { /* Sub-headings within analysis */
             margin-top: 1rem;
             margin-bottom: 0.5rem;
             font-size: 0.9rem; /* Slightly smaller */
             font-weight: 500;
             color: var(--color-text-secondary);
             text-transform: uppercase;
             letter-spacing: 0.05em;
        }


        /* --- Task Placeholder --- */
        .task-placeholder { font-style: italic; color: var(--color-text-tertiary); border: 1px dashed var(--color-border-secondary); padding: 1.5rem; border-radius: var(--radius-md); text-align: center; background-color: rgba(0,0,0,0.1); }

        /* --- Utility Classes (Buttons, Inputs) --- */
        .button { display: inline-flex; align-items: center; justify-content: center; padding: 0.65rem 1.25rem; border-radius: var(--radius-md); font-weight: 500; font-size: 0.95rem; cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease; border: 1px solid transparent; user-select: none; white-space: nowrap; }
        .button:focus-visible { outline: none; box-shadow: 0 0 0 3px var(--color-focus-ring); }
        .button-primary { background-color: var(--color-accent-primary); color: var(--color-accent-text); border-color: var(--color-accent-primary); }
        .button-primary:hover { background-color: var(--color-accent-hover); border-color: var(--color-accent-hover); }
        .button-primary:active { background-color: var(--color-accent-active); border-color: var(--color-accent-active); }
        .button-primary:disabled { background-color: var(--color-bg-tertiary); border-color: var(--color-border-primary); color: var(--color-text-tertiary); cursor: not-allowed; opacity: 0.7; }
        .button-secondary { background-color: var(--color-bg-tertiary); color: var(--color-text-primary); border-color: var(--color-border-primary); }
        .button-secondary:hover { background-color: #2a2f37; border-color: var(--color-border-secondary); }
        .button-secondary:active { background-color: #30363d; }
        .button-secondary:disabled { background-color: var(--color-bg-secondary); border-color: var(--color-border-primary); color: var(--color-text-tertiary); cursor: not-allowed; opacity: 0.6; }
        .button-destructive { background-color: var(--color-error); color: var(--color-accent-text); border-color: var(--color-error); }
        .button-destructive:hover { background-color: #da3633; border-color: #da3633; }
        .button-destructive:active { background-color: #b9251a; border-color: #b9251a; }
        .button-destructive:disabled { background-color: var(--color-bg-tertiary); border-color: var(--color-border-primary); color: var(--color-text-tertiary); cursor: not-allowed; opacity: 0.7; }
        .input-field { display: block; width: 100%; padding: 0.75rem 1rem; background-color: var(--color-bg-primary); color: var(--color-text-primary); border: 1px solid var(--color-border-primary); border-radius: var(--radius-md); font-size: 0.95rem; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        .input-field::placeholder { color: var(--color-text-tertiary); }
        .input-field:focus { outline: none; border-color: var(--color-accent-primary); box-shadow: 0 0 0 3px var(--color-focus-ring); }
        .input-field:disabled { background-color: var(--color-bg-secondary); cursor: not-allowed; opacity: 0.6; }

        /* --- Data Structure Table Styles --- */
        .data-structure-table { width: 100%; border-collapse: collapse; margin-top: 1.5rem; margin-bottom: 2rem; font-size: 0.9em; border: 1px solid var(--color-border-primary); border-radius: var(--radius-md); overflow: hidden; }
        .data-structure-table th, .data-structure-table td { border: 1px solid var(--color-border-primary); padding: 0.85rem 1.1rem; text-align: left; vertical-align: top; }
        .data-structure-table th { background-color: var(--color-bg-tertiary); font-weight: 600; color: var(--color-text-primary); border-bottom: 2px solid var(--color-border-secondary); }
        .data-structure-table tbody tr:nth-child(odd) { background-color: rgba(22, 27, 34, 0.3); }
        .data-structure-table td code { font-size: 0.95em; background-color: var(--color-bg-primary); border-color: var(--color-border-secondary); }
        .data-structure-table td code[class^="nombre-"] { background-color: transparent !important; border: none !important; padding: 0 !important; font-size: inherit !important; vertical-align: baseline !important; }

        /* --- Diagram Placeholder Styles --- */
        .diagram-placeholder { border: 1px dashed var(--color-border-secondary); padding: 2rem; text-align: center; color: var(--color-text-tertiary); border-radius: var(--radius-md); margin: 1.5rem 0; background-color: rgba(0,0,0,0.1); }
        .diagram-placeholder pre { background-color: transparent; border: none; padding: 0; color: inherit; font-size: 0.95em; line-height: 1.4; }

        /* --- Stack Visualization Styles --- */
        .stack-viz { display: flex; justify-content: space-around; margin: 1.5rem 0; padding: 1rem 0; background-color: rgba(0,0,0,0.1); border: 1px solid var(--color-border-primary); border-radius: var(--radius-md); }
        .stack { text-align: center; font-family: var(--font-family-mono); font-size: 0.9em; }
        .stack-title { font-weight: 600; color: var(--color-text-primary); margin-bottom: 0.75rem; border-bottom: 1px solid var(--color-border-secondary); padding-bottom: 0.5rem; }
        .stack-element { display: block; margin: 0.25rem auto; padding: 0.3rem 0.8rem; background-color: var(--color-bg-tertiary); border: 1px solid var(--color-border-primary); border-radius: var(--radius-sm); color: var(--color-text-secondary); min-width: 50px; }
        .stack-element .index { font-size: 0.8em; color: var(--color-highlight-constant); margin-left: 0.5em; }
        .stack-empty { color: var(--color-text-tertiary); font-style: italic; }

        /* --- Mobile Menu Styles --- */
        #mobile-menu { background-color: var(--color-bg-secondary); border-bottom: 1px solid var(--color-border-primary); z-index: 40; }
        #mobile-menu a { border-bottom: 1px solid var(--color-border-primary); color: var(--color-text-secondary); }
        #mobile-menu a:last-child { border-bottom: none; }

        /* --- Sidebar Navigation Styles --- */
        #sidebar { width: var(--sidebar-width); background-color: var(--color-bg-secondary); border-right: 1px solid var(--color-border-primary); }
        #sidebar nav a { color: var(--color-text-secondary); border-left: 3px solid transparent; }
        #sidebar nav a:hover { color: var(--color-text-primary); background-color: var(--color-bg-tertiary); }
        #sidebar nav a.active { color: var(--color-accent-primary); font-weight: 500; border-left-color: var(--color-accent-primary); }

    </style>
</head>
<body class="antialiased text-base">

    <div class="flex">
        <aside id="sidebar" class="hidden md:block h-screen sticky top-0 overflow-y-auto flex-shrink-0">
            <div class="p-4 pt-6">
                 <h3 class="text-lg font-semibold text-white mb-4 pl-2">Navegación</h3>
                 <nav id="sidebar-nav" class="space-y-1 text-sm">
                     <a href="#introduccion" class="block py-2 px-3 rounded-md transition-colors duration-150">Introducción</a>
                     <a href="#tarea-3" class="block py-2 px-3 rounded-md transition-colors duration-150">Ejemplo Visual</a>
                     <a href="#ui-proof-of-concept" class="block py-2 px-3 rounded-md transition-colors duration-150">Análisis</a>
                     <a href="#tarea-4" class="block py-2 px-3 rounded-md transition-colors duration-150 active">Funciones</a>
                     <a href="#tarea-2" class="block py-2 px-3 rounded-md transition-colors duration-150">UI/UX</a>
                     <a href="#tarea-5" class="block py-2 px-3 rounded-md transition-colors duration-150">Traza Detallada</a>
                     <a href="#tarea-6" class="block py-2 px-3 rounded-md transition-colors duration-150">Expansión Análisis</a>
                     <a href="#tarea-7" class="block py-2 px-3 rounded-md transition-colors duration-150">Código Fuente</a>
                     <a href="#glosario" class="block py-2 px-3 rounded-md transition-colors duration-150">Glosario</a>
                     <a href="#uso" class="block py-2 px-3 rounded-md transition-colors duration-150">Cómo Usar</a>
                 </nav>
            </div>
        </aside>

        <div class="flex-grow">
            <header class="bg-gray-900/80 backdrop-blur-md text-white shadow-md sticky top-0 z-50 border-b border-[var(--color-border-primary)]">
                <nav class="container mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 h-16 flex items-center justify-between relative">
                    <div class="flex items-center space-x-4">
                         <i class="fas fa-sort text-xl text-[var(--color-accent-primary)]"></i> <span class="text-xl font-semibold text-[var(--color-text-primary)]">Push_Swap Docs</span>
                    </div>
                    <div class="hidden md:flex space-x-6 text-sm font-medium">
                         <a href="#introduccion" class="text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors">Introducción</a>
                         <a href="#tarea-3" class="text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors">Ejemplo</a>
                         <a href="#ui-proof-of-concept" class="text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors">Análisis</a>
                         <a href="#tarea-4" class="text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors">Funciones</a>
                         <a href="#tarea-2" class="text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors">UI/UX</a>
                         <a href="#tarea-5" class="text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors">Traza</a>
                         <a href="#tarea-6" class="text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors">Expansión</a>
                         <a href="#tarea-7" class="text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors">Código</a>
                         <a href="#glosario" class="text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors">Glosario</a>
                         <a href="#uso" class="text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors">Uso</a>
                    </div>
                    <div class="md:hidden">
                         <button id="mobile-menu-button" class="text-gray-400 hover:text-white focus:outline-none">
                             <i class="fas fa-bars text-xl"></i>
                         </button>
                    </div>
                     <div id="mobile-menu" class="hidden absolute top-full left-0 right-0 bg-[var(--color-bg-secondary)] border-b border-[var(--color-border-primary)] shadow-lg md:hidden">
                         <a href="#introduccion" class="block py-3 px-4 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-tertiary)] transition-colors text-center">Introducción</a>
                         <a href="#tarea-3" class="block py-3 px-4 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-tertiary)] transition-colors text-center">Ejemplo</a>
                         <a href="#ui-proof-of-concept" class="block py-3 px-4 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-tertiary)] transition-colors text-center">Análisis</a>
                         <a href="#tarea-4" class="block py-3 px-4 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-tertiary)] transition-colors text-center">Funciones</a>
                         <a href="#tarea-2" class="block py-3 px-4 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-tertiary)] transition-colors text-center">UI/UX</a>
                         <a href="#tarea-5" class="block py-3 px-4 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-tertiary)] transition-colors text-center">Traza</a>
                         <a href="#tarea-6" class="block py-3 px-4 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-tertiary)] transition-colors text-center">Expansión</a>
                         <a href="#tarea-7" class="block py-3 px-4 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-tertiary)] transition-colors text-center">Código</a>
                         <a href="#glosario" class="block py-3 px-4 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-tertiary)] transition-colors text-center">Glosario</a>
                         <a href="#uso" class="block py-3 px-4 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-tertiary)] transition-colors text-center">Cómo Usar</a>
                     </div>
                </nav>
            </header>

            <main class="container mx-auto max-w-6xl p-4 md:p-8 mt-8">

                <section id="introduccion" class="content-section">
                    <h2>Introducción</h2>
                    <p>
                        Bienvenido a la documentación interactiva del proyecto <code class="concepto-clave">Push_Swap</code>. Este proyecto, parte del currículum de <strong>42</strong>, consiste en ordenar una pila de números enteros utilizando un conjunto limitado de operaciones y dos pilas (<code class="nombre-pila">Pila A</code> y <code class="nombre-pila">Pila B</code>), buscando la secuencia de operaciones más corta posible.
                    </p>
                    <p>
                        Esta página web tiene como objetivo desglosar cada aspecto del proyecto, desde la estructura del código hasta la lógica del algoritmo de ordenación, pasando por el manejo de errores y la parte bonus (el verificador <code class="nombre-archivo">checker</code>). La meta es que cualquier persona, independientemente de su nivel previo de conocimiento sobre el proyecto, pueda comprenderlo en su totalidad al finalizar la lectura.
                    </p>
                     <p>Utilizaremos el código fuente generado por el script proporcionado como base para este análisis. ¡Exploremos juntos las complejidades y soluciones de <code class="concepto-clave">Push_Swap</code>!</p>
                </section>

                <section id="tarea-3" class="content-section">
                     <h2 class="border-b border-[var(--color-border-primary)] pb-2 mb-4">Tarea 3: Desglose Visual del Algoritmo con Ejemplo (N=5)</h2>
                    <p>Para entender mejor cómo funciona el <code class="concepto-clave">Turk Algorithm</code>, sigamos un ejemplo con 5 números: <code>2 1 5 3 4</code>.</p>

                    <h4>1. Estado Inicial y Asignación de Índices</h4>
                    <p>La entrada es <code>2 1 5 3 4</code>. Primero, asignamos los índices relativos (0 al 4):</p>
                    <ul class="list-disc list-inside text-sm mb-4 pl-4">
                        <li>1 -> <code class="nombre-constante">0</code> (el más pequeño)</li>
                        <li>2 -> <code class="nombre-constante">1</code></li>
                        <li>3 -> <code class="nombre-constante">2</code></li>
                        <li>4 -> <code class="nombre-constante">3</code></li>
                        <li>5 -> <code class="nombre-constante">4</code> (el más grande)</li>
                    </ul>
                    <p>La <code class="nombre-pila">Pila A</code> inicial (mostrando valor e índice):</p>
                    <div class="stack-viz">
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila A</code></div>
                            <span class="stack-element">2 <span class="index">(1)</span></span>
                            <span class="stack-element">1 <span class="index">(0)</span></span>
                            <span class="stack-element">5 <span class="index">(4)</span></span>
                            <span class="stack-element">3 <span class="index">(2)</span></span>
                            <span class="stack-element">4 <span class="index">(3)</span></span>
                        </div>
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila B</code></div>
                            <span class="stack-empty">(Vacía)</span>
                        </div>
                    </div>

                    <h4>2. Empuje Inicial a B</h4>
                    <p>Como tenemos más de 3 elementos, movemos los dos primeros a <code class="nombre-pila">B</code> usando <code class="nombre-operacion">pb</code> dos veces.</p>
                    <p>Operación: <code class="nombre-operacion">pb</code></p>
                    <div class="stack-viz">
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila A</code></div>
                            <span class="stack-element">1 <span class="index">(0)</span></span>
                            <span class="stack-element">5 <span class="index">(4)</span></span>
                            <span class="stack-element">3 <span class="index">(2)</span></span>
                            <span class="stack-element">4 <span class="index">(3)</span></span>
                        </div>
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila B</code></div>
                             <span class="stack-element">2 <span class="index">(1)</span></span>
                        </div>
                    </div>
                     <p>Operación: <code class="nombre-operacion">pb</code></p>
                     <div class="stack-viz">
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila A</code></div>
                            <span class="stack-element">5 <span class="index">(4)</span></span>
                            <span class="stack-element">3 <span class="index">(2)</span></span>
                            <span class="stack-element">4 <span class="index">(3)</span></span>
                        </div>
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila B</code></div>
                             <span class="stack-element">1 <span class="index">(0)</span></span>
                             <span class="stack-element">2 <span class="index">(1)</span></span>
                        </div>
                    </div>
                    <p>Ahora <code class="nombre-pila">A</code> tiene 3 elementos y <code class="nombre-pila">B</code> tiene 2.</p>

                    <h4>3. Ordenar los 3 Elementos en A</h4>
                    <p>La <code class="nombre-pila">Pila A</code> contiene (de arriba a abajo) índices <code>4, 2, 3</code>. Aplicamos <code class="nombre-funcion">sort_three</code>. El caso es <code class="concepto-clave">3-1-2</code> (comparando índices: 4 > 2, 2 < 3, 4 > 3), que se resuelve con <code class="nombre-operacion">ra</code>.</p>
                    <p>Operación: <code class="nombre-operacion">ra</code></p>
                     <div class="stack-viz">
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila A</code></div>
                            <span class="stack-element">3 <span class="index">(2)</span></span>
                            <span class="stack-element">4 <span class="index">(3)</span></span>
                            <span class="stack-element">5 <span class="index">(4)</span></span>
                        </div>
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila B</code></div>
                             <span class="stack-element">1 <span class="index">(0)</span></span>
                             <span class="stack-element">2 <span class="index">(1)</span></span>
                        </div>
                    </div>
                    <p>La <code class="nombre-pila">Pila A</code> ahora está ordenada (índices <code>2, 3, 4</code>).</p>

                    <h4>4. Devolver Elementos de B a A</h4>
                    <p>Ahora movemos los elementos de <code class="nombre-pila">B</code> de vuelta a <code class="nombre-pila">A</code>, calculando su posición objetivo en <code class="nombre-pila">A</code>.</p>

                    <p><strong>Elemento a mover:</strong> Nodo con valor 1 (índice <code class="nombre-constante">0</code>) de <code class="nombre-pila">B</code>.</p>
                    <ul class="list-disc list-inside text-sm mb-2 pl-4">
                        <li><strong>Calcular <code class="nombre-campo">target_pos</code> en A:</strong> Buscamos el índice inmediatamente mayor que 0 en A. Es el índice 2 (valor 3), que está en la posición 0 de A. Por tanto, <code class="nombre-campo">target_pos</code> = 0.</li>
                        <li><strong>Calcular Coste A:</strong> Para llevar la posición 0 a la cima de A, el coste es 0.</li>
                        <li><strong>Ejecutar Rotaciones:</strong> No se necesitan rotaciones en A.</li>
                        <li><strong>Empujar a A:</strong> <code class="nombre-operacion">pa</code></li>
                    </ul>
                     <p>Operación: <code class="nombre-operacion">pa</code></p>
                     <div class="stack-viz">
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila A</code></div>
                            <span class="stack-element">1 <span class="index">(0)</span></span>
                            <span class="stack-element">3 <span class="index">(2)</span></span>
                            <span class="stack-element">4 <span class="index">(3)</span></span>
                            <span class="stack-element">5 <span class="index">(4)</span></span>
                        </div>
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila B</code></div>
                             <span class="stack-element">2 <span class="index">(1)</span></span>
                        </div>
                    </div>

                    <p><strong>Elemento a mover:</strong> Nodo con valor 2 (índice <code class="nombre-constante">1</code>) de <code class="nombre-pila">B</code>.</p>
                     <ul class="list-disc list-inside text-sm mb-2 pl-4">
                        <li><strong>Calcular <code class="nombre-campo">target_pos</code> en A:</strong> Buscamos el índice inmediatamente mayor que 1 en A. Es el índice 2 (valor 3), que está en la posición 1 de A. Por tanto, <code class="nombre-campo">target_pos</code> = 1.</li>
                        <li><strong>Calcular Coste A:</strong> Para llevar la posición 1 a la cima de A (tamaño 4), el coste es 1 (<code class="nombre-operacion">ra</code>).</li>
                        <li><strong>Ejecutar Rotaciones:</strong> <code class="nombre-operacion">ra</code></li>
                        <li><strong>Empujar a A:</strong> <code class="nombre-operacion">pa</code></li>
                    </ul>
                     <p>Operación: <code class="nombre-operacion">ra</code></p>
                     <div class="stack-viz">
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila A</code></div>
                            <span class="stack-element">3 <span class="index">(2)</span></span>
                            <span class="stack-element">4 <span class="index">(3)</span></span>
                            <span class="stack-element">5 <span class="index">(4)</span></span>
                             <span class="stack-element">1 <span class="index">(0)</span></span>
                        </div>
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila B</code></div>
                             <span class="stack-element">2 <span class="index">(1)</span></span>
                        </div>
                    </div>
                     <p>Operación: <code class="nombre-operacion">pa</code></p>
                     <div class="stack-viz">
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila A</code></div>
                            <span class="stack-element">2 <span class="index">(1)</span></span>
                            <span class="stack-element">3 <span class="index">(2)</span></span>
                            <span class="stack-element">4 <span class="index">(3)</span></span>
                            <span class="stack-element">5 <span class="index">(4)</span></span>
                             <span class="stack-element">1 <span class="index">(0)</span></span>
                        </div>
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila B</code></div>
                             <span class="stack-empty">(Vacía)</span>
                        </div>
                    </div>
                    <p>La <code class="nombre-pila">Pila B</code> está vacía.</p>

                    <h4>5. Alineación Final en A</h4>
                    <p>La <code class="nombre-pila">Pila A</code> contiene los índices <code>1, 2, 3, 4, 0</code>. No está completamente ordenada porque el índice 0 no está en la cima. Buscamos el nodo con índice 0 (valor 1), que está en la posición 4.</p>
                     <ul class="list-disc list-inside text-sm mb-2 pl-4">
                         <li><strong>Calcular Coste:</strong> La pila tiene tamaño 5. La posición 4 está más cerca del final. El coste es 4 - 5 = -1 (<code class="nombre-operacion">rra</code>).</li>
                         <li><strong>Ejecutar Rotación:</strong> <code class="nombre-operacion">rra</code></li>
                     </ul>
                     <p>Operación: <code class="nombre-operacion">rra</code></p>
                     <div class="stack-viz">
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila A</code></div>
                            <span class="stack-element">1 <span class="index">(0)</span></span>
                            <span class="stack-element">2 <span class="index">(1)</span></span>
                            <span class="stack-element">3 <span class="index">(2)</span></span>
                            <span class="stack-element">4 <span class="index">(3)</span></span>
                            <span class="stack-element">5 <span class="index">(4)</span></span>
                        </div>
                        <div class="stack">
                            <div class="stack-title"><code class="nombre-pila">Pila B</code></div>
                             <span class="stack-empty">(Vacía)</span>
                        </div>
                    </div>
                    <p>¡La <code class="nombre-pila">Pila A</code> está ahora completamente ordenada!</p>

                    <h4>Secuencia Final de Operaciones</h4>
                    <p>La secuencia generada para este ejemplo fue: <code class="nombre-operacion">pb</code>, <code class="nombre-operacion">pb</code>, <code class="nombre-operacion">ra</code>, <code class="nombre-operacion">pa</code>, <code class="nombre-operacion">ra</code>, <code class="nombre-operacion">pa</code>, <code class="nombre-operacion">rra</code>.</p>
                     <p class="text-sm text-[var(--color-text-tertiary)]"><em>Nota: Este es un ejemplo simplificado. El algoritmo real calcula costes para todos los elementos de A en cada paso de la fase 3, lo que podría llevar a secuencias diferentes pero igualmente válidas (y potencialmente más cortas en casos más complejos).</em></p>
                </section>

                <section id="ui-proof-of-concept" class="content-section">
                     <h2 class="border-b border-[var(--color-border-primary)] pb-2 mb-4">Profundización del Análisis (Inicio, Estructuras, Algoritmo)</h2>
                    <p>Esta sección profundiza en los componentes fundamentales que definen el comportamiento y la lógica del programa <code class="nombre-archivo">push_swap</code>.</p>
                    <h3 class="text-lg font-semibold mb-4 mt-6">Punto de Entrada: <code class="nombre-archivo">main.c</code></h3>
                    <p>
                        La función <code class="nombre-funcion">main</code> actúa como el <code class="concepto-clave">director de orquesta</code> del programa. Su responsabilidad principal es inicializar el entorno, validar las entradas y dirigir el flujo hacia la lógica de ordenación.
                    </p>
                     <p>
                        Antes de sumergirnos en el algoritmo, es crucial entender cómo se procesa la entrada. <code class="nombre-archivo">Push_Swap</code> debe aceptar números como argumentos de línea de comandos de dos formas: múltiples argumentos (<code>./push_swap 1 5 2 4</code>) o un único argumento string (<code>./push_swap "1 5 2 4"</code>). La función <code class="nombre-funcion">main</code>, junto con <code class="nombre-funcion">parse_arguments</code>, maneja esta flexibilidad y realiza validaciones exhaustivas.
                    </p>
                    <ul class="list-disc list-inside space-y-3 mb-4 text-[var(--color-text-secondary)] pl-4">
                        <li>
                            <strong>Inicialización:</strong> Se crea e inicializa la estructura <code class="nombre-struct">t_stacks</code> (<code class="nombre-campo">stacks.a = NULL</code>, <code class="nombre-campo">stacks.b = NULL</code>, etc.) usando <code class="nombre-funcion">init_stacks_struct</code>. Esto asegura un estado limpio antes de cualquier operación.
                        </li>
                        <li>
                            <strong>Validación de Argumentos (<code>argc < 2</code>):</strong> Si no se proporcionan argumentos (aparte del nombre del programa), no hay nada que ordenar, por lo que el programa termina exitosamente (<code class="nombre-constante">EXIT_SUCCESS</code>).
                        </li>
                        <li>
                            <strong>Parsing y Validación Detallada (<code class="nombre-funcion">parse_arguments</code>):</strong> Esta es una <code class="concepto-clave">fase crucial</code>. La función <code class="nombre-funcion">parse_arguments</code> (y sus funciones auxiliares o *helpers*) se encarga de:
                            <ul class="list-disc list-inside space-y-2 mt-2 ml-6 text-sm">
                                <li>Manejar tanto un <strong>único argumento</strong> (string entre comillas con números separados por espacios) como <strong>múltiples argumentos</strong> (cada uno un número).</li>
                                <li>Utilizar <code class="nombre-funcion">ft_split</code> si es necesario para dividir el string (y guardar el resultado en <code class="nombre-campo">stacks.split_args</code> para liberarlo después).</li>
                                <li>Validar que cada argumento/número sea un <code class="concepto-clave">entero válido</code> (usando <code class="nombre-funcion">is_valid_int_str</code>) y esté dentro de los límites de <code class="nombre-constante">INT_MAX</code> y <code class="nombre-constante">INT_MIN</code> (usando <code class="nombre-funcion">ft_atol</code> para detectar <code class="concepto-clave">overflow/underflow</code>).</li>
                                <li>Crear nodos (<code class="nombre-funcion">new_node</code>) con el valor entero validado.</li>
                                <li>Añadir los nodos creados a la <code class="nombre-pila">Pila A</code> (usando <code class="nombre-funcion">add_node_back</code>).</li>
                                <li>Verificar la ausencia de <code class="concepto-clave">números duplicados</code> (<code class="nombre-funcion">has_duplicates</code>) una vez que todos los números están en la <code class="nombre-pila">Pila A</code>.</li>
                                <li><strong>Gestionar errores:</strong> Si cualquier validación falla, se llama a <code class="nombre-funcion">exit_error</code>, que imprime "Error", libera toda la memoria asignada (pilas y <code class="nombre-campo">split_args</code>) y termina el programa con <code class="nombre-constante">EXIT_FAILURE</code>.</li>
                            </ul>
                        </li>
                         <li>
                            <strong>Comprobación Post-Parsing:</strong>
                            <ul class="list-disc list-inside space-y-1 mt-2 ml-6 text-sm">
                                <li>Si <code class="nombre-campo">stacks.size_a == 0</code> (por ejemplo, si el argumento fue una cadena vacía como <code>""</code>), el programa termina correctamente.</li>
                                <li>Si la <code class="nombre-pila">Pila A</code> ya está ordenada (verificado con <code class="nombre-funcion">is_sorted</code>), no se necesita hacer nada y el programa termina exitosamente. Esta es una <code class="concepto-clave">optimización importante</code>.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Asignación de Índices (<code class="nombre-funcion">assign_index</code>):</strong> Antes de ordenar, se asigna un <code class="concepto-clave">índice único</code> a cada nodo basado en su valor relativo (0 para el más pequeño, N-1 para el más grande). Esto simplifica enormemente la lógica de ordenación posterior, permitiendo trabajar con valores normalizados de 0 a N-1.
                        </li>
                        <li>
                            <strong>Llamada a la Ordenación (<code class="nombre-funcion">sort_stack</code>):</strong> Si la pila no está vacía ni ordenada, se llama a la función principal que contiene la lógica del algoritmo de ordenación (el <code class="concepto-clave">Turk Algorithm</code> en este caso).
                        </li>
                        <li>
                            <strong>Limpieza Final (<code class="nombre-funcion">free_stacks</code>):</strong> Antes de terminar (<code class="nombre-constante">EXIT_SUCCESS</code>), se libera toda la memoria asignada para los nodos de las pilas <code class="nombre-pila">A</code> y <code class="nombre-pila">B</code>, y para <code class="nombre-campo">split_args</code> si se utilizó. Es crucial para evitar <code class="concepto-clave">fugas de memoria</code> (*memory leaks*).
                        </li>
                    </ul>
                    <pre><code class="language-c">// Fragmento simplificado de main.c con comentarios clave
#include "../../includes/push_swap.h"

// Inicializa la estructura principal t_stacks
static void init_stacks_struct(t_stacks *stacks) { /* ... */ }

int main(int argc, char **argv) {
    t_stacks stacks; // Estructura que contiene las pilas A, B y sus tamaños

    init_stacks_struct(&stacks); // Pone punteros a NULL, tamaños a 0

    // 1. Validación básica de argumentos
    if (argc < 2) return (EXIT_SUCCESS); // No hay números que ordenar

    // 2. Parsing y Validación detallada de los argumentos
    if (!parse_arguments(argc, argv, &stacks)) {
        // Si parse_arguments devuelve 0 (error), libera memoria y sale
        free_stacks(&stacks); // Libera nodos de A/B y split_args si existe
        ft_putstr_fd(ERROR_MSG, STDERR_FD); // Imprime "Error" a stderr
        return (EXIT_FAILURE); // Termina con código de error
    }

    // 3. Comprobación post-parsing
    if (stacks.size_a == 0) { // Input válido pero vacío (ej: "./push_swap "" ")
        free_stacks(&stacks);
        return (EXIT_SUCCESS);
    }

    // 4. Optimización: Comprobar si ya está ordenado
    if (is_sorted(stacks.a)) {
        free_stacks(&stacks);
        return (EXIT_SUCCESS); // No hacer nada si ya está ordenado
    }

    // 5. Preparación para la ordenación: Asignar índices
    // Convierte los valores originales a índices relativos (0 a N-1)
    assign_index(stacks.a, stacks.size_a);

    // 6. Ejecutar el algoritmo de ordenación principal
    sort_stack(&stacks); // Llama a la lógica que mueve elementos entre A y B

    // 7. Limpieza final antes de salir
    free_stacks(&stacks); // Libera toda la memoria dinámica
    return (EXIT_SUCCESS); // Termina correctamente
}</code></pre>

                    <h3 class="text-lg font-semibold mb-4 mt-8">Estructuras de Datos</h3>
                    <p>La elección de las estructuras de datos es fundamental para la eficiencia y la lógica del algoritmo.</p>

                    <h4 class="mb-3"><code class="nombre-struct">t_stack_node</code>: El Nodo de la Pila</h4>
                    <p>Representa un elemento individual dentro de las pilas <code class="nombre-pila">A</code> o <code class="nombre-pila">B</code>. Se implementa como un nodo de una <code class="concepto-clave">lista doblemente enlazada circular</code>. Esta elección es clave para la eficiencia de las operaciones de rotación.</p>
                    <table class="data-structure-table">
                        <thead>
                            <tr>
                                <th>Campo</th>
                                <th>Tipo</th>
                                <th>Descripción</th>
                                <th>Justificación</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code class="nombre-campo">value</code></td>
                                <td><code class="nombre-tipo">int</code></td>
                                <td>El número entero original proporcionado como argumento.</td>
                                <td>Almacena el dato principal que se debe ordenar.</td>
                            </tr>
                            <tr>
                                <td><code class="nombre-campo">index</code></td>
                                <td><code class="nombre-tipo">int</code></td>
                                <td>El <code class="concepto-clave">índice relativo</code> del nodo (0 = más pequeño, N-1 = más grande). Calculado por <code class="nombre-funcion">assign_index</code>.</td>
                                <td><strong>Fundamental:</strong> Simplifica comparaciones y la lógica de ordenación, independientemente de los valores absolutos. Permite tratar <code class="nombre-constante">-500, 0, 1000</code> igual que <code class="nombre-constante">0, 1, 2</code>.</td>
                            </tr>
                            <tr>
                                <td><code class="nombre-campo">pos</code></td>
                                <td><code class="nombre-tipo">int</code></td>
                                <td>La <code class="concepto-clave">posición actual</code> del nodo dentro de su pila (0 = top, 1, 2...). Actualizado dinámicamente por <code class="nombre-funcion">update_positions</code>.</td>
                                <td>Necesario para calcular los costes de rotación (cuántos <code class="nombre-operacion">ra</code>/<code class="nombre-operacion">rra</code> o <code class="nombre-operacion">rb</code>/<code class="nombre-operacion">rrb</code> se necesitan).</td>
                            </tr>
                            <tr>
                                <td><code class="nombre-campo">target_pos</code></td>
                                <td><code class="nombre-tipo">int</code></td>
                                <td>La <code class="concepto-clave">posición objetivo</code> que este nodo deveria ocupar en la <em>otra</em> pila para una inserción óptima. Calculado por <code class="nombre-funcion">assign_target_pos_a</code>/<code class="nombre-funcion">b</code>.</td>
                                <td><strong>Clave para el <code class="concepto-clave">Turk Algorithm</code>:</strong> Indica dónde (en qué posición de la pila destino) debería insertarse un nodo para mantener el orden relativo.</td>
                            </tr>
                            <tr>
                                <td><code class="nombre-campo">cost_a</code></td>
                                <td><code class="nombre-tipo">int</code></td>
                                <td>El coste (número de rotaciones <code class="nombre-operacion">ra</code>/<code class="nombre-operacion">rra</code>) para llevar este nodo (si está en A) o su <code class="nombre-campo">target_pos</code> (si está en B) a la cima de la <code class="nombre-pila">Pila A</code>.</td>
                                <td rowspan="2">Calcula el número de movimientos necesarios en cada pila. Se usa un valor <strong>positivo</strong> para rotaciones (<code class="nombre-operacion">ra</code>/<code class="nombre-operacion">rb</code>) y <strong>negativo</strong> para rotaciones inversas (<code class="nombre-operacion">rra</code>/<code class="nombre-operacion">rrb</code>). Permite encontrar el movimiento combinado más barato (usando <code class="nombre-operacion">rr</code>/<code class="nombre-operacion">rrr</code> cuando sea posible).</td>
                            </tr>
                            <tr>
                                <td><code class="nombre-campo">cost_b</code></td>
                                <td><code class="nombre-tipo">int</code></td>
                                <td>El coste (número de rotaciones <code class="nombre-operacion">rb</code>/<code class="nombre-operacion">rrb</code>) para llevar este nodo (si está en B) o su <code class="nombre-campo">target_pos</code> (si está en A) a la cima de la <code class="nombre-pila">Pila B</code>.</td>
                            </tr>
                            <tr>
                                <td><code class="nombre-campo">prev</code></td>
                                <td><code class="nombre-tipo">struct s_stack_node *</code></td>
                                <td>Puntero al nodo <strong>anterior</strong> en la lista circular.</td>
                                <td rowspan="2">Permiten la navegación <strong>bidireccional</strong> y hacen que las operaciones <code class="nombre-operacion">rotate</code> (<code class="nombre-operacion">r</code>) y <code class="nombre-operacion">reverse_rotate</code> (<code class="nombre-operacion">rr</code>) sean extremadamente eficientes (<strong>O(1)</strong>), ya que la "cola" (<code class="nombre-campo">head->prev</code>) y la "cabeza" (<code class="nombre-campo">head</code>) son accesibles directamente y solo se necesita reasignar punteros.</td>
                            </tr>
                            <tr>
                                <td><code class="nombre-campo">next</code></td>
                                <td><code class="nombre-tipo">struct s_stack_node *</code></td>
                                <td>Puntero al nodo <strong>siguiente</strong> en la lista circular.</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>¿Por qué una <code class="concepto-clave">lista doblemente enlazada circular</code>?</strong></p>
                    <ul class="list-disc list-inside space-y-2 mb-4 text-[var(--color-text-secondary)] pl-4">
                        <li><strong>Eficiencia de Rotaciones (O(1)):</strong> Las operaciones <code class="nombre-operacion">rotate</code> (<code class="nombre-operacion">ra</code>, <code class="nombre-operacion">rb</code>, <code class="nombre-operacion">rr</code>) y <code class="nombre-operacion">reverse_rotate</code> (<code class="nombre-operacion">rra</code>, <code class="nombre-operacion">rrb</code>, <code class="nombre-operacion">rrr</code>) se implementan simplemente cambiando el puntero a la cabeza de la lista (<code class="nombre-campo">*stack = (*stack)->next</code> para <code class="nombre-operacion">r</code> o <code class="nombre-campo">*stack = (*stack)->prev</code> para <code class="nombre-operacion">rr</code>). Esto es una operación de <strong>tiempo constante</strong>, crucial para la eficiencia del algoritmo. En una lista lineal o array, estas operaciones serían O(N).</li>
                        <li><strong>Acceso Directo a la Cola:</strong> El último elemento (la "cola") es accesible directamente desde la cabeza (<code class="nombre-campo">head->prev</code>), lo cual es útil para operaciones como <code class="nombre-operacion">rra</code>/<code class="nombre-operacion">rrb</code> y para añadir elementos al final (aunque <code class="nombre-archivo">push_swap</code> principalmente añade al principio).</li>
                        <li><strong>Flexibilidad en Modificaciones:</strong> Aunque <code class="nombre-operacion">push</code> (<code class="nombre-operacion">pa</code>, <code class="nombre-operacion">pb</code>) siempre opera en la cabeza, la estructura permite inserciones/eliminaciones eficientes en cualquier punto si fuera necesario (aunque no se use extensivamente en push_swap más allá del push/pop en la cabeza).</li>
                    </ul>

                     <div class="diagram-placeholder">
                        <p><strong>Diagrama Conceptual: Lista Doblemente Enlazada Circular (Refinado)</strong></p>
                        <pre class="bg-transparent border-none p-0 text-center text-sm">
       next -->+---------+      +---------+      +---------+<-- prev       
               | Head: 0 |----->| Node: 1 |----->| Node: 2 |          
(Tail: N)<---- +---------+      +---------+      +---------+-----> ... ->(Tail: N)
       prev <--                                                next -->
                        ^                                |
                        |-------- next / prev ------------| (Tail->next = Head, Head->prev = Tail)
                        </pre>
                        <p>Cada nodo tiene punteros <code>next</code> y <code>prev</code>. El <code>next</code> del último apunta al primero, y el <code>prev</code> del primero apunta al último.</p>
                    </div>

                    <h4 class="mb-3"><code class="nombre-struct">t_stacks</code>: El Contenedor Principal</h4>
                    <p>Esta estructura agrupa las dos pilas (<code class="nombre-pila">A</code> y <code class="nombre-pila">B</code>) y metadatos asociados, facilitando pasar toda la información necesaria entre funciones.</p>
                     <table class="data-structure-table">
                        <thead>
                            <tr>
                                <th>Campo</th>
                                <th>Tipo</th>
                                <th>Descripción</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code class="nombre-campo">a</code></td>
                                <td><code class="nombre-tipo">t_stack_node *</code></td>
                                <td>Puntero a la cabeza (nodo superior) de la <strong><code class="nombre-pila">Pila A</code></strong>. <code class="nombre-constante">NULL</code> si está vacía.</td>
                            </tr>
                            <tr>
                                <td><code class="nombre-campo">b</code></td>
                                <td><code class="nombre-tipo">t_stack_node *</code></td>
                                <td>Puntero a la cabeza (nodo superior) de la <strong><code class="nombre-pila">Pila B</code></strong>. <code class="nombre-constante">NULL</code> si está vacía.</td>
                            </tr>
                            <tr>
                                <td><code class="nombre-campo">size_a</code></td>
                                <td><code class="nombre-tipo">int</code></td>
                                <td>Número actual de elementos en la <code class="nombre-pila">Pila A</code>. Se actualiza en <code class="nombre-operacion">pa</code>/<code class="nombre-operacion">pb</code>.</td>
                            </tr>
                             <tr>
                                <td><code class="nombre-campo">size_b</code></td>
                                <td><code class="nombre-tipo">int</code></td>
                                <td>Número actual de elementos en la <code class="nombre-pila">Pila B</code>. Se actualiza en <code class="nombre-operacion">pa</code>/<code class="nombre-operacion">pb</code>.</td>
                            </tr>
                            <tr>
                                <td><code class="nombre-campo">split_args</code></td>
                                <td><code class="nombre-tipo">char **</code></td>
                                <td>Almacena el resultado de <code class="nombre-funcion">ft_split</code> si se usó un solo argumento string. Necesario para liberar la memoria correctamente al final con <code class="nombre-funcion">free_stacks</code>. <code class="nombre-constante">NULL</code> si se usaron múltiples argumentos.</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3 class="text-lg font-semibold mb-4 mt-8">Algoritmo de Ordenación: Visión General (<code class="concepto-clave">Turk Algorithm</code>)</h3>
                    <p>
                        Dado que no podemos acceder directamente a los elementos de la pila excepto al superior, ni usar operaciones de comparación y swap arbitrarias, los algoritmos de ordenación clásicos (como QuickSort, MergeSort, etc.) no son aplicables directamente. Necesitamos una estrategia que funcione únicamente con las operaciones permitidas: <code class="nombre-operacion">sa</code>/<code class="nombre-operacion">sb</code>/<code class="nombre-operacion">ss</code>, <code class="nombre-operacion">pa</code>/<code class="nombre-operacion">pb</code>, <code class="nombre-operacion">ra</code>/<code class="nombre-operacion">rb</code>/<code class="nombre-operacion">rr</code>, y <code class="nombre-operacion">rra</code>/<code class="nombre-operacion">rrb</code>/<code class="nombre-operacion">rrr</code>.
                    </p>
                    <p>
                        El <code class="concepto-clave">Turk Algorithm</code> es una <code class="concepto-clave">heurística</code> popular para <code class="nombre-archivo">push_swap</code>. Su idea central es usar la <code class="nombre-pila">Pila B</code> como un área temporal para mover elementos de <code class="nombre-pila">A</code> de forma inteligente, dejando <code class="nombre-pila">A</code> con pocos elementos (3) que son fáciles de ordenar. Luego, los elementos se devuelven de <code class="nombre-pila">B</code> a <code class="nombre-pila">A</code>, insertándolos en su posición ordenada correcta.
                    </p>
                    <p><strong>Fases Principales:</strong></p>
                    <ol class="list-decimal list-inside space-y-3 mb-4 text-[var(--color-text-secondary)] pl-4">
                        <li>
                            <strong>Preparación e Indexación:</strong> Como se vio en <code class="nombre-funcion">main</code>, se valida la entrada y se asignan <code class="concepto-clave">índices únicos</code> a cada número (<code class="nombre-funcion">assign_index</code>). Esto es crucial para el resto del algoritmo.
                        </li>
                        <li>
                            <strong>Empuje Inicial a B (<code class="nombre-funcion">push_initial_to_b</code>):</strong> Se mueven los dos primeros elementos de <code class="nombre-pila">A</code> a <code class="nombre-pila">B</code> (usando <code class="nombre-operacion">do_pb</code>), a menos que la <code class="nombre-pila">Pila A</code> ya tenga 3 o menos elementos. Esto crea espacio en <code class="nombre-pila">A</code> y establece una base en <code class="nombre-pila">B</code> para calcular las posiciones objetivo.
                        </li>
                        <li>
                            <strong>Iteración Principal (Bucle en <code class="nombre-funcion">turk_sort</code>):</strong> Mientras queden más de 3 elementos en <code class="nombre-pila">A</code> y <code class="nombre-pila">A</code> no esté ordenada:
                            <ul class="list-disc list-inside space-y-2 mt-2 ml-6 text-sm">
                                <li><strong>Actualizar Estado:</strong> Se recalculan las posiciones actuales (<code class="nombre-campo">pos</code>) de cada nodo en ambas pilas (<code class="nombre-funcion">update_positions</code>). Es necesario porque las rotaciones y pushes cambian las posiciones.</li>
                                <li><strong>Calcular Posiciones Objetivo en B:</strong> Para cada nodo en <code class="nombre-pila">A</code>, se determina cuál sería su posición ideal (<code class="nombre-campo">target_pos</code>) si se moviera a <code class="nombre-pila">B</code> (<code class="nombre-funcion">assign_target_pos_b</code> y <code class="nombre-funcion">get_target_pos_in_b</code>). El objetivo en <code class="nombre-pila">B</code> es generalmente el nodo con el índice <strong>inmediatamente más pequeño</strong> que el índice del nodo de <code class="nombre-pila">A</code>. Si no hay uno más pequeño, el objetivo es el nodo con el índice <strong>más grande</strong> de <code class="nombre-pila">B</code> (para mantener la circularidad del orden).</li>
                                <li><strong>Calcular Costes de Movimiento:</strong> Para cada nodo en <code class="nombre-pila">A</code>, se calcula el coste (<code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code>) para llevar tanto el nodo de <code class="nombre-pila">A</code> a la cima de <code class="nombre-pila">A</code> como su nodo objetivo en <code class="nombre-pila">B</code> a la cima de <code class="nombre-pila">B</code> (<code class="nombre-funcion">calculate_cost_to_b</code>). Se calcula el camino más corto (<code class="nombre-operacion">r</code> vs <code class="nombre-operacion">rr</code>).</li>
                                <li><strong>Encontrar el Movimiento Más Barato:</strong> Se identifica el nodo en <code class="nombre-pila">A</code> cuyo <code class="concepto-clave">movimiento combinado</code> (considerando rotaciones simultáneas <code class="nombre-operacion">rr</code>/<code class="nombre-operacion">rrr</code> si los costes tienen el mismo signo) sea el más económico (<code class="nombre-funcion">find_cheapest_node</code> y <code class="nombre-funcion">calculate_combined_cost</code>).</li>
                                <li><strong>Ejecutar y Empujar:</strong> Se realizan las rotaciones calculadas (<code class="nombre-funcion">execute_rotations</code>) para llevar el nodo elegido y su objetivo a la cima, y luego se empuja el nodo más barato de <code class="nombre-pila">A</code> a <code class="nombre-pila">B</code> (<code class="nombre-operacion">do_pb</code>).</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Ordenar los Tres Restantes en A (<code class="nombre-funcion">sort_three</code>):</strong> Cuando <code class="nombre-pila">A</code> tiene exactamente 3 elementos, se aplica una lógica específica (con un máximo de 2 operaciones: <code class="nombre-operacion">sa</code>, <code class="nombre-operacion">ra</code>, <code class="nombre-operacion">rra</code>) para ordenarlos eficientemente.
                        </li>
                        <li>
                            <strong>Devolver Elementos a A (<code class="nombre-funcion">move_all_to_a</code>):</strong> Mientras <code class="nombre-pila">B</code> no esté vacía:
                             <ul class="list-disc list-inside space-y-2 mt-2 ml-6 text-sm">
                                 <li>Se actualizan posiciones y se calcula la <code class="concepto-clave">posición objetivo en A</code> para el nodo superior de <code class="nombre-pila">B</code> (<code class="nombre-funcion">assign_target_pos_a</code>). El objetivo en <code class="nombre-pila">A</code> es el nodo con el índice <strong>inmediatamente más grande</strong> que el índice del nodo de <code class="nombre-pila">B</code>. Si no existe (el nodo de <code class="nombre-pila">B</code> es el más grande de todos), el objetivo es el nodo con el índice <strong>más pequeño</strong> de <code class="nombre-pila">A</code>.</li>
                                 <li>Se calcula el coste para llevar esa posición objetivo en <code class="nombre-pila">A</code> a la cima (<code class="nombre-funcion">calculate_cost_to_a</code>).</li>
                                 <li>Se rota <code class="nombre-pila">A</code> hasta que la posición objetivo esté en la cima (<code class="nombre-funcion">rotate_a_to_top</code>).</li>
                                 <li>Se empuja el elemento de <code class="nombre-pila">B</code> a <code class="nombre-pila">A</code> (<code class="nombre-operacion">do_pa</code>), insertándolo en el lugar correcto.</li>
                             </ul>
                        </li>
                         <li>
                            <strong>Alineación Final en A (<code class="nombre-funcion">final_sort_a</code>):</strong> Una vez que todos los elementos están de vuelta en <code class="nombre-pila">A</code> (y teóricamente ordenados), se busca el nodo con <code class="concepto-clave">índice 0</code> (el más pequeño) y se rota <code class="nombre-pila">A</code> (usando <code class="nombre-operacion">ra</code> o <code class="nombre-operacion">rra</code>, lo que sea más corto) hasta que este nodo quede en la cima. Esto asegura que la pila esté completamente ordenada y comience con el elemento más pequeño, cumpliendo el requisito final.
                         </li>
                    </ol>
                    <h4>Nota sobre la Eficiencia</h4>
                    <p>
                        El objetivo principal de <code class="nombre-archivo">push_swap</code> es encontrar una secuencia de operaciones <strong>lo más corta posible</strong>. El <code class="concepto-clave">Turk Algorithm</code> intenta lograr esto mediante decisiones <code class="concepto-clave">localmente óptimas</code>: en cada paso de la fase principal, calcula el "coste" de mover cada elemento de <code class="nombre-pila">A</code> a <code class="nombre-pila">B</code> (considerando las rotaciones necesarias en ambas pilas) y elige el elemento con el coste combinado más bajo.
                    </p>
                    <p>
                        Si bien esta estrategia es generalmente muy eficiente y produce resultados considerablemente mejores que enfoques más simples, <strong>no garantiza matemáticamente</strong> la solución con el número mínimo absoluto de operaciones en todos los casos posibles (eso sería un problema mucho más complejo computacionalmente). Sin embargo, es una heurística muy efectiva para el propósito del proyecto 42.
                    </p>
                     <div class="diagram-placeholder">
                         <p><strong>Diagrama de Flujo Conceptual del Algoritmo Turk (Refinado)</strong></p>
                         <pre class="bg-transparent border-none p-0 text-sm text-left overflow-x-auto">
+-------------------------+     +-----------------------+     +-------------------+
| <strong>Inicio</strong>                  | --> | Parsear & Validar Args| --> | Asignar Índices   |
+-------------------------+     +-----------------------+     +-------------------+
           |
           V
+-------------------------+     +-------------------------------------------------+
| Empujar Iniciales a B   | --> | <strong>Bucle Principal</strong> (Mientras size_a > 3 y !sorted) |
| (si size_a > 3)         |     +-------------------------------------------------+
+-------------------------+                 |
                                            V
                             +---------------------------------+
                             | <strong>Iteración (Elegir y Mover a B)</strong> |
                             | 1. Actualizar Posiciones        |
                             | 2. Calcular Target_Pos (en B)   |
                             | 3. Calcular Costos (cost_a/b)   |
                             | 4. Encontrar Nodo + Barato      |
                             | 5. Ejecutar Rotaciones (A y B)  |
                             | 6. Empujar a B (<code class="nombre-operacion">do_pb</code>)          |-----> (Vuelve al inicio del Bucle)
                             +---------------------------------+
                                            | (Cuando size_a <= 3)
                                            V
+-------------------------+     +-------------------------------------------------+
| Ordenar 3 en A          | --> | <strong>Bucle Devolución</strong> (Mientras size_b > 0)          |
| (<code class="nombre-funcion">sort_three</code>)        |     +-------------------------------------------------+
+-------------------------+                 |
                                            V
                             +---------------------------------+
                             | <strong>Iteración (Devolver a A)</strong>       |
                             | 1. Actualizar Posiciones        |
                             | 2. Calcular Target_Pos (en A)   |
                             | 3. Calcular Costo A             |
                             | 4. Rotar A a Target_Pos         |
                             | 5. Empujar a A (<code class="nombre-operacion">do_pa</code>)          |-----> (Vuelve al inicio del Bucle)
                             +---------------------------------+
                                            | (Cuando size_b == 0)
                                            V
+-------------------------+     +-------------------------+
| Rotación Final en A     | --> | <strong>Fin</strong>                    |
| (<code class="nombre-funcion">final_sort_a</code>)      |     +-------------------------+
+-------------------------+
                         </pre>
                    </div>
                </section>

                <section id="tarea-4" class="content-section">
                    <h2 class="border-b border-[var(--color-border-primary)] pb-2 mb-4">Tarea 4: Análisis Funcional Exhaustivo</h2>
                    <p>En esta sección, analizaremos en detalle las funciones clave de los archivos <code>.c</code> del proyecto, excluyendo <code>libft</code>.</p>

                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md">
                            <code class="nombre-archivo">mandatory/srcs/main.c</code> (1/28)
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">init_stacks_struct</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Inicializar los campos de la estructura principal <code class="nombre-struct">t_stacks</code> a sus valores por defecto (<code class="nombre-constante">NULL</code> para punteros, 0 para tamaños) antes de empezar a procesar los argumentos.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura que contiene las pilas y metadatos.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <p>Asigna <code class="nombre-constante">NULL</code> a los punteros de las pilas <code class="nombre-campo">a</code> y <code class="nombre-campo">b</code>, y a <code class="nombre-campo">split_args</code>. Asigna 0 a los tamaños <code class="nombre-campo">size_a</code> y <code class="nombre-campo">size_b</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void init_stacks_struct(t_stacks *stacks)
{
    stacks->a = NULL;
    stacks->b = NULL;
    stacks->size_a = 0;
    stacks->size_b = 0;
    stacks->split_args = NULL;
}</code></pre>
                                </div>
                            </details>
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">main</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Punto de entrada principal del programa <code class="nombre-archivo">push_swap</code>. Orquesta la validación de argumentos, la inicialización de las pilas, la asignación de índices, la ejecución del algoritmo de ordenación y la limpieza final.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int argc</code>: Número de argumentos de la línea de comandos.</li>
                                        <li><code class="nombre-tipo">char **argv</code>: Array de strings con los argumentos.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-constante">EXIT_SUCCESS</code> (0): Si el programa se ejecuta correctamente (incluyendo casos sin argumentos, entrada vacía o ya ordenada).</li>
                                        <li><code class="nombre-constante">EXIT_FAILURE</code> (1): Si ocurre un error durante el parsing o validación.</li>
                                    </ul>
                                    <h5>Lógica Principal</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Llama a <code class="nombre-funcion">init_stacks_struct</code> para inicializar la estructura <code class="nombre-struct">stacks</code>.</li>
                                        <li>Comprueba si <code class="nombre-tipo">argc</code> es menor que 2. Si es así, no hay números que ordenar y retorna <code class="nombre-constante">EXIT_SUCCESS</code>.</li>
                                        <li>Llama a <code class="nombre-funcion">parse_arguments</code> para procesar los argumentos (<code class="nombre-tipo">argv</code>) y llenar la <code class="nombre-pila">Pila A</code>.</li>
                                        <li>Si <code class="nombre-funcion">parse_arguments</code> devuelve error (0), libera memoria con <code class="nombre-funcion">free_stacks</code>, imprime "Error" y retorna <code class="nombre-constante">EXIT_FAILURE</code>.</li>
                                        <li>Comprueba si la <code class="nombre-pila">Pila A</code> está vacía (<code class="nombre-campo">stacks.size_a == 0</code>) después del parsing. Si es así, libera memoria y retorna <code class="nombre-constante">EXIT_SUCCESS</code>.</li>
                                        <li>Comprueba si la <code class="nombre-pila">Pila A</code> ya está ordenada usando <code class="nombre-funcion">is_sorted</code>. Si es así, libera memoria y retorna <code class="nombre-constante">EXIT_SUCCESS</code> (optimización).</li>
                                        <li>Si la pila no está vacía ni ordenada, llama a <code class="nombre-funcion">assign_index</code> para calcular y asignar los índices relativos a cada nodo en <code class="nombre-pila">A</code>.</li>
                                        <li>Llama a <code class="nombre-funcion">sort_stack</code> para ejecutar el algoritmo principal de ordenación.</li>
                                        <li>Finalmente, llama a <code class="nombre-funcion">free_stacks</code> para liberar toda la memoria dinámica asignada.</li>
                                        <li>Retorna <code class="nombre-constante">EXIT_SUCCESS</code>.</li>
                                    </ol>
                                     <h5>Dependencias</h5>
                                     <p class="text-sm">Llama a: <code class="nombre-funcion">init_stacks_struct</code>, <code class="nombre-funcion">parse_arguments</code>, <code class="nombre-funcion">free_stacks</code>, <code class="nombre-funcion">ft_putstr_fd</code>, <code class="nombre-funcion">is_sorted</code>, <code class="nombre-funcion">assign_index</code>, <code class="nombre-funcion">sort_stack</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int main(int argc, char **argv)
{
    t_stacks stacks;

    init_stacks_struct(&stacks);
    if (argc < 2)
        return (EXIT_SUCCESS);
    if (!parse_arguments(argc, argv, &stacks))
    {
        free_stacks(&stacks);
        ft_putstr_fd(ERROR_MSG, STDERR_FD);
        return (EXIT_FAILURE);
    }
    if (stacks.size_a == 0)
    {
        free_stacks(&stacks);
        return (EXIT_SUCCESS);
    }
    if (is_sorted(stacks.a))
    {
        free_stacks(&stacks);
        return (EXIT_SUCCESS);
    }
    assign_index(stacks.a, stacks.size_a);
    sort_stack(&stacks);
    free_stacks(&stacks);
    return (EXIT_SUCCESS);
}</code></pre>
                                </div>
                            </details>
                        </div>
                    </details>

                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md">
                            <code class="nombre-archivo">mandatory/srcs/utils/errors.c</code> (2/28)
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">free_stack</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Liberar la memoria de todos los nodos de una pila (lista doblemente enlazada circular).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node **stack</code>: Puntero al puntero de la cabeza de la pila a liberar. Se usa doble puntero para poder poner el puntero original a <code class="nombre-constante">NULL</code>.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si el doble puntero o la pila son <code class="nombre-constante">NULL</code>. Si es así, no hace nada.</li>
                                        <li>Guarda el puntero al último nodo (<code class="nombre-campo">head->prev</code>).</li>
                                        <li>Rompe la circularidad estableciendo el <code class="nombre-campo">next</code> del último nodo a <code class="nombre-constante">NULL</code>.</li>
                                        <li>Itera desde la cabeza original (<code class="nombre-campo">head</code>) hasta el final (<code class="nombre-constante">NULL</code>).</li>
                                        <li>En cada iteración, guarda el puntero al siguiente nodo, libera el nodo actual con <code class="nombre-funcion">free</code> y avanza al siguiente.</li>
                                        <li>Finalmente, establece el puntero original de la pila (<code>*stack</code>) a <code class="nombre-constante">NULL</code>.</li>
                                    </ol>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void free_stack(t_stack_node **stack)
{
    t_stack_node    *current;
    t_stack_node    *head;
    t_stack_node    *next_node;
    t_stack_node    *last;

    if (!stack || !*stack)
        return ;
    head = *stack;
    last = head->prev; // Get the tail node
    if (last)
        last->next = NULL; // Break the circular link
    current = head;
    while (current)
    {
        next_node = current->next; // Store next node
        free(current);             // Free current node
        current = next_node;       // Move to the next
    }
    *stack = NULL; // Set the original stack pointer to NULL
}</code></pre>
                                </div>
                            </details>

                             <details class="function-analysis">
                                <summary><code class="nombre-funcion">free_split_args</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Liberar la memoria asignada por <code class="nombre-funcion">ft_split</code> para el array de strings <code class="nombre-campo">split_args</code>.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char **args</code>: El array de strings devuelto por <code class="nombre-funcion">ft_split</code>.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <p>Utiliza la función <code class="nombre-funcion">ft_free_split</code> (asumiendo que existe en <code>libft</code>) para liberar cada string del array y luego el propio array.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void free_split_args(char **args)
{
    if (args)
        ft_free_split(args); // Assumes ft_free_split exists in libft
}</code></pre>
                                </div>
                            </details>

                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">free_stacks</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Liberar toda la memoria asociada a la estructura <code class="nombre-struct">t_stacks</code>, incluyendo ambas pilas (<code class="nombre-pila">A</code> y <code class="nombre-pila">B</code>) y el array <code class="nombre-campo">split_args</code> si fue utilizado.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si el puntero <code class="nombre-struct">stacks</code> es <code class="nombre-constante">NULL</code>.</li>
                                        <li>Llama a <code class="nombre-funcion">free_stack</code> para liberar la <code class="nombre-pila">Pila A</code> (<code class="nombre-campo">stacks->a</code>).</li>
                                        <li>Llama a <code class="nombre-funcion">free_stack</code> para liberar la <code class="nombre-pila">Pila B</code> (<code class="nombre-campo">stacks->b</code>).</li>
                                        <li>Comprueba si <code class="nombre-campo">stacks->split_args</code> no es <code class="nombre-constante">NULL</code> (lo que indica que se usó <code class="nombre-funcion">ft_split</code>).</li>
                                        <li>Si no es <code class="nombre-constante">NULL</code>, llama a <code class="nombre-funcion">free_split_args</code> para liberar el array y lo establece a <code class="nombre-constante">NULL</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">free_stack</code>, <code class="nombre-funcion">free_split_args</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void free_stacks(t_stacks *stacks)
{
    if (!stacks)
        return ;
    free_stack(&(stacks->a));
    free_stack(&(stacks->b));
    if (stacks->split_args)
    {
        free_split_args(stacks->split_args);
        stacks->split_args = NULL;
    }
}</code></pre>
                                </div>
                            </details>

                             <details class="function-analysis">
                                <summary><code class="nombre-funcion">exit_error</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Función centralizada para manejar errores fatales. Imprime un mensaje de error, libera toda la memoria asignada y termina el programa.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal (puede ser <code class="nombre-constante">NULL</code> si el error ocurre antes de su inicialización completa).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Imprime el mensaje "Error\n" en la salida de error estándar (<code class="nombre-constante">STDERR_FD</code>) usando <code class="nombre-funcion">ft_putstr_fd</code>.</li>
                                        <li>Si el puntero <code class="nombre-struct">stacks</code> no es <code class="nombre-constante">NULL</code>, llama a <code class="nombre-funcion">free_stacks</code> para liberar toda la memoria asociada.</li>
                                        <li>Termina la ejecución del programa con el código de estado <code class="nombre-constante">EXIT_FAILURE</code> (generalmente 1).</li>
                                    </ol>
                                     <h5>Dependencias</h5>
                                     <p class="text-sm">Llama a: <code class="nombre-funcion">ft_putstr_fd</code>, <code class="nombre-funcion">free_stacks</code>, <code class="nombre-funcion">exit</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void exit_error(t_stacks *stacks)
{
    ft_putstr_fd(ERROR_MSG, STDERR_FD);
    if (stacks)
    {
        free_stacks(stacks);
    }
    exit(EXIT_FAILURE);
}</code></pre>
                                </div>
                            </details>
                        </div>
                    </details>

                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md">
                             <code class="nombre-archivo">mandatory/srcs/parsing/parsing.c</code> (3/28)
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">parse_arguments</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Función principal para procesar los argumentos de línea de comandos. Determina si se trata de un argumento único (string) o múltiples argumentos, y llama a la función de parsing correspondiente. También realiza la comprobación final de duplicados.</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int argc</code>: Número de argumentos.</li>
                                        <li><code class="nombre-tipo">char **argv</code>: Array de argumentos.</li>
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal para almacenar la pila y el resultado de <code class="nombre-funcion">ft_split</code> si se usa.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-constante">1</code>: Si el parsing y la validación son exitosos.</li>
                                        <li><code class="nombre-constante">0</code>: Si ocurre un error (delegado a <code class="nombre-funcion">exit_error</code> por las funciones llamadas).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Si <code class="nombre-tipo">argc</code> es 2 (un solo argumento después del nombre del programa):
                                            <ul><li>Comprueba si el argumento es una cadena vacía. Si lo es, retorna 1 (éxito, no hay números).</li>
                                            <li>Llama a <code class="nombre-funcion">parse_single_arg</code> para procesar el string.</li></ul>
                                        </li>
                                        <li>Si <code class="nombre-tipo">argc</code> es mayor que 2:
                                            <ul><li>Llama a <code class="nombre-funcion">parse_multiple_args</code> para procesar cada argumento como un número.</li></ul>
                                        </li>
                                        <li>Si alguna de las funciones de parsing falló (aunque en este código llaman a <code class="nombre-funcion">exit_error</code> directamente), la variable <code class="nombre-tipo">success</code> sería 0 y se llamaría a <code class="nombre-funcion">exit_error</code> (redundante en esta implementación, pero podría ser útil en otras).</li>
                                        <li>Calcula el tamaño de la <code class="nombre-pila">Pila A</code> usando <code class="nombre-funcion">get_stack_size</code> y lo guarda en <code class="nombre-campo">stacks->size_a</code>.</li>
                                        <li>Si el tamaño es 0 pero el parsing fue exitoso (ej. <code>./push_swap ""</code>), retorna 1.</li>
                                        <li>Si el tamaño es mayor que 0, llama a <code class="nombre-funcion">has_duplicates</code> para verificar duplicados. Si los hay, llama a <code class="nombre-funcion">exit_error</code>.</li>
                                        <li>Si todo está bien, retorna 1.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">parse_single_arg</code>, <code class="nombre-funcion">parse_multiple_args</code>, <code class="nombre-funcion">exit_error</code>, <code class="nombre-funcion">get_stack_size</code>, <code class="nombre-funcion">has_duplicates</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int parse_arguments(int argc, char **argv, t_stacks *stacks)
{
    int success;

    success = 1;
    if (argc == 2)
    {
        if (argv[1][0] == '\0') // Handle empty string argument
            return (1);
        success = parse_single_arg(argv[1], stacks);
    }
    else
    {
        success = parse_multiple_args(argc, argv, stacks);
    }
    // In this specific implementation, parse_single/multiple_args call exit_error
    // directly on failure, so checking 'success' here is slightly redundant.
    if (!success)
        exit_error(stacks);
    stacks->size_a = get_stack_size(stacks->a);
    if (stacks->size_a == 0 && success) // Handle case like "./push_swap """
        return (1);
    if (stacks->size_a > 0 && has_duplicates(stacks->a))
        exit_error(stacks); // Check for duplicates after all numbers are added
    return (1); // Success
}</code></pre>
                                </div>
                            </details>

                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">is_sorted</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Verificar si una pila (lista circular) está ordenada ascendentemente según sus valores.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack</code>: Puntero a la cabeza de la pila a verificar.</li>
                                    </ul>
                                     <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-constante">1</code>: Si la pila está ordenada o si está vacía o tiene un solo elemento.</li>
                                        <li><code class="nombre-constante">0</code>: Si la pila no está ordenada.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Si la pila es <code class="nombre-constante">NULL</code> o solo tiene un nodo (<code>stack->next == stack</code>), se considera ordenada y retorna 1.</li>
                                        <li>Itera a través de la lista circular, empezando desde la cabeza.</li>
                                        <li>En cada paso, compara el <code class="nombre-campo">value</code> del nodo actual con el <code class="nombre-campo">value</code> del siguiente nodo.</li>
                                        <li>Si en algún punto el valor actual es mayor que el siguiente, la pila no está ordenada y retorna 0.</li>
                                        <li>Si completa el ciclo sin encontrar ningún desorden, retorna 1.</li>
                                    </ol>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int is_sorted(t_stack_node *stack)
{
    t_stack_node    *current;

    if (!stack || stack->next == stack) // Empty or single node is sorted
        return (1);
    current = stack;
    while (current->next != stack) // Iterate until the node before head
    {
        if (current->value > current->next->value)
            return (0); // Not sorted
        current = current->next;
    }
    return (1); // Sorted
}</code></pre>
                                </div>
                            </details>

                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">assign_index</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Asignar un índice relativo (0 al N-1) a cada nodo de la <code class="nombre-pila">Pila A</code> basado en su valor numérico. El nodo con el valor más pequeño obtiene índice 0, el siguiente más pequeño obtiene 1, y así sucesivamente.</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack_a</code>: Puntero a la cabeza de la <code class="nombre-pila">Pila A</code>.</li>
                                        <li><code class="nombre-tipo">int size</code>: El número total de elementos en la pila.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Itera sobre cada nodo de la pila (<code class="nombre-tipo">current</code>).</li>
                                        <li>Para cada nodo <code class="nombre-tipo">current</code>, inicializa su futuro índice (<code class="nombre-tipo">index_val</code>) a 0.</li>
                                        <li>Realiza una segunda iteración completa sobre la pila (<code class="nombre-tipo">compare</code>).</li>
                                        <li>Dentro del bucle interno, compara el valor del nodo <code class="nombre-tipo">compare</code> con el valor del nodo <code class="nombre-tipo">current</code>.</li>
                                        <li>Si <code class="nombre-campo">compare->value</code> es menor que <code class="nombre-campo">current->value</code>, incrementa <code class="nombre-tipo">index_val</code>.</li>
                                        <li>Después de comparar <code class="nombre-tipo">current</code> con todos los demás nodos, el valor final de <code class="nombre-tipo">index_val</code> representa cuántos números son más pequeños que el valor de <code class="nombre-tipo">current</code>, que es exactamente su índice relativo deseado (0-based).</li>
                                        <li>Asigna <code class="nombre-tipo">index_val</code> al campo <code class="nombre-campo">index</code> del nodo <code class="nombre-tipo">current</code>.</li>
                                        <li>Repite para todos los nodos de la pila.</li>
                                    </ol>
                                    <h5>Nota</h5>
                                    <p class="text-sm">Este enfoque tiene una complejidad de O(N^2), donde N es el tamaño de la pila. Para pilas muy grandes, podría ser más eficiente copiar los valores a un array, ordenarlo y luego asignar los índices basados en la posición en el array ordenado (O(N log N)). Sin embargo, para los límites típicos de <code class="nombre-archivo">push_swap</code>, O(N^2) suele ser aceptable para esta fase inicial.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void assign_index(t_stack_node *stack_a, int size)
{
    t_stack_node    *current;
    t_stack_node    *compare;
    int             index_val;
    int             i;

    if (!stack_a)
        return ;
    current = stack_a;
    while (1) // Loop through each node to assign its index
    {
        index_val = 0; // Reset index counter for the current node
        compare = stack_a; // Start comparison from the beginning
        i = 0;
        while (i < size) // Compare 'current' with all other nodes
        {
            if (compare->value < current->value)
                index_val++; // Increment if 'compare' node is smaller
            compare = compare->next;
            i++;
        }
        current->index = index_val; // Assign the calculated index
        current = current->next; // Move to the next node
        if (current == stack_a) // Stop when we've looped back to the start
            break ;
    }
}</code></pre>
                                </div>
                            </details>
                        </div>
                    </details>

                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md">
                             <code class="nombre-archivo">mandatory/srcs/parsing/parsing_utils.c</code> (4/28)
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">is_valid_int_str</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Comprobar si una cadena de caracteres representa un número entero válido (puede tener un signo opcional al principio seguido únicamente de dígitos).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">const char *str</code>: La cadena a validar.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-constante">1</code>: Si la cadena es un entero válido.</li>
                                        <li><code class="nombre-constante">0</code>: Si la cadena es <code class="nombre-constante">NULL</code>, vacía, contiene caracteres no numéricos (después del signo opcional), o si solo contiene un signo.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si la cadena es <code class="nombre-constante">NULL</code> o vacía.</li>
                                        <li>Comprueba si el primer carácter es un signo (<code>-</code> o <code>+</code>). Si lo es, avanza al siguiente carácter y comprueba que no sea el final de la cadena.</li>
                                        <li>Comprueba si el carácter actual (el primero o el siguiente al signo) es un dígito. Si no lo es, retorna 0.</li>
                                        <li>Itera por el resto de la cadena. Si encuentra algún carácter que no sea un dígito, retorna 0.</li>
                                        <li>Si llega al final de la cadena sin encontrar caracteres inválidos, retorna 1.</li>
                                    </ol>
                                     <h5>Dependencias</h5>
                                     <p class="text-sm">Llama a: <code class="nombre-funcion">ft_isdigit</code> (de libft).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int is_valid_int_str(const char *str)
{
    int i;

    i = 0;
    if (!str || str[0] == '\0') // Check for NULL or empty string
        return (0);
    if (str[i] == '-' || str[i] == '+') // Check for optional sign
    {
        i++;
        if (str[i] == '\0') // String contains only a sign
            return (0);
    }
    if (!ft_isdigit(str[i])) // First char (or after sign) must be digit
        return (0);
    while (str[i]) // Check remaining characters
    {
        if (!ft_isdigit(str[i]))
            return (0); // Invalid character found
        i++;
    }
    return (1); // String is a valid integer representation
}</code></pre>
                                </div>
                            </details>

                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">has_duplicates</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Verificar si hay valores duplicados dentro de una pila (lista circular).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack</code>: Puntero a la cabeza de la pila a verificar.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-constante">1</code>: Si se encuentra al menos un valor duplicado.</li>
                                        <li><code class="nombre-constante">0</code>: Si no hay duplicados, o si la pila está vacía o tiene un solo elemento.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Si la pila es <code class="nombre-constante">NULL</code> o tiene un solo nodo, retorna 0 (no puede haber duplicados).</li>
                                        <li>Utiliza dos bucles anidados para comparar cada nodo con todos los nodos que le siguen en la lista.
                                            <ul><li>El bucle exterior (<code class="nombre-tipo">outer</code>) itera desde la cabeza hasta el final.</li>
                                            <li>El bucle interior (<code class="nombre-tipo">inner</code>) empieza desde el nodo siguiente a <code class="nombre-tipo">outer</code> y también itera hasta el final.</li></ul>
                                        </li>
                                        <li>Dentro del bucle interior, si <code class="nombre-campo">outer->value == inner->value</code>, se ha encontrado un duplicado y retorna 1.</li>
                                        <li>Si se completan ambos bucles sin encontrar duplicados, retorna 0.</li>
                                    </ol>
                                     <h5>Nota</h5>
                                     <p class="text-sm">Este enfoque tiene una complejidad de O(N^2). Alternativamente, se podría usar una estructura de datos auxiliar (como un hash set o un árbol binario de búsqueda) para comprobar duplicados en O(N) o O(N log N) a costa de mayor uso de memoria, o ordenar una copia de los valores y comprobar elementos adyacentes (O(N log N)).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int has_duplicates(t_stack_node *stack)
{
    t_stack_node    *outer;
    t_stack_node    *inner;

    if (!stack || stack->next == stack) // Empty or single node: no duplicates
        return (0);
    outer = stack;
    while (1) // Outer loop iterates through each node
    {
        inner = outer->next; // Inner loop starts from the next node
        while (inner != stack) // Compare outer with all subsequent nodes
        {
            if (outer->value == inner->value)
                return (1); // Duplicate found
            inner = inner->next;
        }
        outer = outer->next; // Move outer pointer
        if (outer == stack) // Stop when outer loop completes a cycle
            break ;
    }
    return (0); // No duplicates found
}</code></pre>
                                </div>
                            </details>

                             <details class="function-analysis">
                                <summary><code class="nombre-funcion">parse_single_arg</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Procesar el caso en que todos los números se pasan como un único argumento string (ej. <code>"1 2 3"</code>).</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *arg_str</code>: La cadena que contiene los números separados por espacios.</li>
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-constante">1</code>: Si el parsing es exitoso.</li>
                                        <li><code class="nombre-constante">0</code>: Si ocurre un error durante el split o la validación/conversión de algún número (delegado a <code class="nombre-funcion">add_num_to_stack</code> que llama a <code class="nombre-funcion">exit_error</code>).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Divide la cadena de entrada <code class="nombre-tipo">arg_str</code> en subcadenas usando el espacio como delimitador, mediante <code class="nombre-funcion">ft_split</code>. Almacena el resultado (array de strings) en <code class="nombre-campo">stacks->split_args</code>.</li>
                                        <li>Si <code class="nombre-funcion">ft_split</code> falla (devuelve <code class="nombre-constante">NULL</code>), llama a <code class="nombre-funcion">exit_error</code>.</li>
                                        <li>Si el resultado de <code class="nombre-funcion">ft_split</code> es un array vacío (ej. entrada <code>" "</code>), libera el array y retorna 1 (éxito, no hay números).</li>
                                        <li>Itera sobre cada subcadena en el array <code class="nombre-campo">stacks->split_args</code>.</li>
                                        <li>Para cada subcadena, llama a <code class="nombre-funcion">add_num_to_stack</code> para validarla, convertirla a entero, crear un nodo y añadirlo a la <code class="nombre-pila">Pila A</code>.</li>
                                        <li>Si <code class="nombre-funcion">add_num_to_stack</code> detecta un error (formato inválido, overflow/underflow), devuelve 0 (y esta función también retornará 0, aunque <code class="nombre-funcion">add_num_to_stack</code> ya habrá llamado a <code class="nombre-funcion">exit_error</code>).</li>
                                        <li>Si todas las subcadenas se procesan correctamente, retorna 1.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">ft_split</code>, <code class="nombre-funcion">exit_error</code>, <code class="nombre-funcion">ft_free_split</code>, <code class="nombre-funcion">add_num_to_stack</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int parse_single_arg(char *arg_str, t_stacks *stacks)
{
    int             i;

    i = 0;
    stacks->split_args = ft_split(arg_str, ' '); // Split the string by spaces
    if (!stacks->split_args) // Check if ft_split failed
        exit_error(stacks);
    // Check if split resulted in an empty array (e.g., input was only spaces)
    if (stacks->split_args[0] == NULL)
    {
        ft_free_split(stacks->split_args); // Free the empty array
        stacks->split_args = NULL;
        return (1); // Valid input, but no numbers
    }
    while (stacks->split_args[i]) // Iterate through the split strings
    {
        // Validate, convert, create node, and add to stack A
        if (!add_num_to_stack(stacks, stacks->split_args[i]))
            return (0); // Error handled by add_num_to_stack calling exit_error
        i++;
    }
    // Note: stacks->split_args needs to be freed later by free_stacks
    return (1); // Success
}</code></pre>
                                </div>
                            </details>

                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">parse_multiple_args</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Procesar el caso en que cada número se pasa como un argumento separado en la línea de comandos (ej. <code>./push_swap 1 2 3</code>).</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int argc</code>: Número total de argumentos.</li>
                                        <li><code class="nombre-tipo">char **argv</code>: Array de argumentos.</li>
                                         <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-constante">1</code>: Si el parsing es exitoso.</li>
                                        <li><code class="nombre-constante">0</code>: Si ocurre un error durante la validación/conversión de algún número (delegado a <code class="nombre-funcion">add_num_to_stack</code>).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Itera sobre los argumentos de la línea de comandos, empezando desde el índice 1 (saltando el nombre del programa, <code class="nombre-campo">argv[0]</code>) hasta <code class="nombre-tipo">argc - 1</code>.</li>
                                        <li>Para cada argumento <code class="nombre-campo">argv[i]</code>, llama a <code class="nombre-funcion">add_num_to_stack</code> para validarlo, convertirlo, crear un nodo y añadirlo a la <code class="nombre-pila">Pila A</code>.</li>
                                        <li>Si <code class="nombre-funcion">add_num_to_stack</code> falla, retorna 0 (el error ya fue manejado por <code class="nombre-funcion">exit_error</code>).</li>
                                        <li>Si todos los argumentos se procesan correctamente, retorna 1.</li>
                                    </ol>
                                     <h5>Dependencias</h5>
                                     <p class="text-sm">Llama a: <code class="nombre-funcion">add_num_to_stack</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int parse_multiple_args(int argc, char **argv, t_stacks *stacks)
{
    int             i;

    i = 1; // Start from the first actual argument (index 1)
    while (i < argc)
    {
        // Validate, convert, create node, and add to stack A for each argument
        if (!add_num_to_stack(stacks, argv[i]))
            return (0); // Error handled by add_num_to_stack calling exit_error
        i++;
    }
    return (1); // Success
}</code></pre>
                                </div>
                            </details>
                        </div>
                    </details>

                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                         <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md">
                             <code class="nombre-archivo">mandatory/srcs/parsing/parsing_utils_helpers.c</code> (5/28)
                         </summary>
                         <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                             <details class="function-analysis">
                                 <summary><code class="nombre-funcion">add_num_to_stack</code></summary>
                                 <div>
                                     <h5>Propósito</h5>
                                     <p>Validar una cadena como entero, convertirla, crear un nuevo nodo <code class="nombre-struct">t_stack_node</code> con ese valor y añadirlo al final de la <code class="nombre-pila">Pila A</code>.</p>
                                     <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal (necesario para la gestión de errores y para acceder a la pila A).</li>
                                         <li><code class="nombre-tipo">const char *num_str</code>: La cadena que representa el número a añadir.</li>
                                     </ul>
                                     <h5>Retorno</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-constante">1</code>: Si el número es válido, se convierte, se crea el nodo y se añade a la pila correctamente.</li>
                                         <li><code class="nombre-constante">0</code>: Si la cadena no es un entero válido o si el número está fuera del rango <code class="nombre-constante">INT_MAX</code>/<code class="nombre-constante">INT_MIN</code> (en estos casos, llama a <code class="nombre-funcion">exit_error</code> antes de retornar).</li>
                                     </ul>
                                     <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                         <li>Valida si la cadena <code class="nombre-tipo">num_str</code> representa un entero usando <code class="nombre-funcion">is_valid_int_str</code>. Si no, retorna 0 (error).</li>
                                         <li>Convierte la cadena a <code class="nombre-tipo">long</code> usando <code class="nombre-funcion">ft_atol</code>. Se usa <code class="nombre-tipo">long</code> para detectar *overflow/underflow* del tipo <code class="nombre-tipo">int</code>.</li>
                                         <li>Comprueba si el valor <code class="nombre-tipo">long</code> resultante (<code class="nombre-tipo">num_l</code>) es igual a <code class="nombre-constante">LLONG_MAX</code> o <code class="nombre-constante">LLONG_MIN</code> (indicando error en <code class="nombre-funcion">ft_atol</code>) o si es mayor que <code class="nombre-constante">INT_MAX</code> o menor que <code class="nombre-constante">INT_MIN</code>. Si alguna condición se cumple, retorna 0 (error).</li>
                                         <li>Si el número es válido y está en rango, crea un nuevo nodo usando <code class="nombre-funcion">new_node</code>, casteando el valor <code class="nombre-tipo">long</code> a <code class="nombre-tipo">int</code>.</li>
                                         <li>Si la creación del nodo falla (<code class="nombre-funcion">new_node</code> devuelve <code class="nombre-constante">NULL</code>, probablemente por fallo de <code class="nombre-funcion">malloc</code>), llama a <code class="nombre-funcion">exit_error</code>.</li>
                                         <li>Añade el nuevo nodo al final de la <code class="nombre-pila">Pila A</code> usando <code class="nombre-funcion">add_node_back</code>.</li>
                                         <li>Retorna 1 (éxito).</li>
                                     </ol>
                                     <h5>Dependencias</h5>
                                     <p class="text-sm">Llama a: <code class="nombre-funcion">is_valid_int_str</code>, <code class="nombre-funcion">ft_atol</code>, <code class="nombre-funcion">new_node</code>, <code class="nombre-funcion">exit_error</code>, <code class="nombre-funcion">add_node_back</code>.</p>
                                     <h5>Código</h5>
                                     <pre><code class="language-c">int add_num_to_stack(t_stacks *stacks, const char *num_str)
{
    long            num_l;
    t_stack_node    *node;

    if (!is_valid_int_str(num_str)) // 1. Validate format
        return (0);
    num_l = ft_atol(num_str); // 2. Convert to long
    // 3. Check for overflow/underflow
    if (num_l == LLONG_MAX || num_l == LLONG_MIN ||
        num_l > INT_MAX || num_l < INT_MIN)
        return (0);
    node = new_node((int)num_l); // 4. Create node
    if (!node) // 5. Check node creation
        exit_error(stacks); // Exit if malloc failed
    add_node_back(&(stacks->a), node); // 6. Add node to stack A
    return (1); // Success
}</code></pre>
                                 </div>
                             </details>
                         </div>
                     </details>
                     <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <code class="nombre-archivo">mandatory/srcs/stack/stack_utils.c</code> (6/28)
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">new_node</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Crear y inicializar un nuevo nodo (<code class="nombre-struct">t_stack_node</code>) para ser añadido a una de las pilas.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int value</code>: El valor entero que contendrá el nuevo nodo.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *</code>: Un puntero al nodo recién creado y inicializado.</li>
                                        <li><code class="nombre-constante">NULL</code>: Si falla la asignación de memoria (<code class="nombre-funcion">malloc</code>).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Reserva memoria del tamaño de <code class="nombre-struct">t_stack_node</code> usando <code class="nombre-funcion">malloc</code>.</li>
                                        <li>Si <code class="nombre-funcion">malloc</code> falla, retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>Asigna el <code class="nombre-campo">value</code> proporcionado al campo <code class="nombre-campo">value</code> del nodo.</li>
                                        <li>Inicializa todos los demás campos a valores por defecto o inválidos (<code class="nombre-campo">index</code>, <code class="nombre-campo">pos</code>, <code class="nombre-campo">target_pos</code>, <code class="nombre-campo">cost_a</code>, <code class="nombre-campo">cost_b</code> a -1).</li>
                                        <li>Configura los punteros <code class="nombre-campo">prev</code> y <code class="nombre-campo">next</code> para que apunten al propio nodo. Esto lo prepara como un nodo independiente que puede ser insertado en una lista circular (donde inicialmente será el único elemento).</li>
                                        <li>Retorna el puntero al nodo creado.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">malloc</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">t_stack_node    *new_node(int value)
            {
                t_stack_node    *node;
            
                node = (t_stack_node *)malloc(sizeof(t_stack_node));
                if (!node)
                    return (NULL);
                node->value = value;
                node->index = -1;
                node->pos = -1;
                node->target_pos = -1;
                node->cost_a = -1;
                node->cost_b = -1;
                node->prev = node; // Point to self for circular list initialization
                node->next = node; // Point to self for circular list initialization
                return (node);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">add_node_back</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Añadir un nodo existente al final (la "parte trasera" o "bottom") de una pila implementada como lista doblemente enlazada circular.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node **stack</code>: Doble puntero a la cabeza de la pila. Se necesita doble puntero para modificar la cabeza si la pila estaba vacía.</li>
                                        <li><code class="nombre-tipo">t_stack_node *node</code>: Puntero al nodo que se va a añadir.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si el doble puntero <code class="nombre-tipo">stack</code> o el puntero <code class="nombre-tipo">node</code> son <code class="nombre-constante">NULL</code>. Si es así, no hace nada.</li>
                                        <li>Si la pila está vacía (<code>*stack == NULL</code>):
                                            <ul><li>El nuevo nodo se convierte en la cabeza de la pila (<code>*stack = node</code>). Como el nodo ya apunta a sí mismo (<code class="nombre-campo">prev</code> y <code class="nombre-campo">next</code>), la lista circular de un elemento queda correctamente formada.</li></ul>
                                        </li>
                                        <li>Si la pila no está vacía:
                                            <ul>
                                                <li>Obtiene el nodo actual que está al final (la "cola") accediendo a <code class="nombre-campo">(*stack)->prev</code>.</li>
                                                <li>Actualiza los punteros para insertar el nuevo nodo entre la cola actual y la cabeza:
                                                    <ul>
                                                        <li><code>tail->next = node;</code> (El siguiente de la antigua cola es el nuevo nodo)</li>
                                                        <li><code>node->prev = tail;</code> (El anterior del nuevo nodo es la antigua cola)</li>
                                                        <li><code>node->next = *stack;</code> (El siguiente del nuevo nodo es la cabeza)</li>
                                                        <li><code>(*stack)->prev = node;</code> (El anterior de la cabeza es el nuevo nodo, que ahora es la nueva cola)</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ol>
                                     <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                   <h5>Código</h5>
                                    <pre><code class="language-c">void    add_node_back(t_stack_node **stack, t_stack_node *node)
            {
                t_stack_node    *tail;
            
                if (!stack || !node)
                    return ;
                if (*stack == NULL) // If stack is empty
                {
                    *stack = node; // The new node becomes the head
                    // node->prev and node->next already point to node itself from new_node
                }
                else // If stack is not empty
                {
                    tail = (*stack)->prev; // Get the current tail node
                    tail->next = node;     // Link current tail's next to the new node
                    node->prev = tail;     // Link new node's prev to the current tail
                    node->next = *stack;   // Link new node's next to the head
                    (*stack)->prev = node; // Link head's prev to the new node (new tail)
                }
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">get_stack_bottom</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Obtener un puntero al último nodo (el nodo "bottom" o "tail") de la pila circular.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack</code>: Puntero a la cabeza de la pila.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *</code>: Puntero al último nodo de la pila.</li>
                                        <li><code class="nombre-constante">NULL</code>: Si la pila está vacía (<code class="nombre-constante">NULL</code>).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si la pila es <code class="nombre-constante">NULL</code>. Si lo es, retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>En una lista doblemente enlazada circular, el puntero <code class="nombre-campo">prev</code> del nodo cabeza apunta directamente al último nodo. Retorna <code class="nombre-campo">stack->prev</code>.</li>
                                    </ol>
                                     <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">t_stack_node    *get_stack_bottom(t_stack_node *stack)
            {
                if (!stack)
                    return (NULL);
                // In a circular doubly linked list, the head's previous node is the tail
                return (stack->prev);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">get_stack_size</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Calcular y devolver el número de nodos presentes en la pila circular.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack</code>: Puntero a la cabeza de la pila.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                       <li><code class="nombre-tipo">int</code>: El número de nodos en la pila (0 si está vacía).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Inicializa un contador <code class="nombre-tipo">size</code> a 0.</li>
                                        <li>Comprueba si la pila es <code class="nombre-constante">NULL</code>. Si lo es, retorna 0.</li>
                                        <li>Establece un puntero <code class="nombre-tipo">current</code> a la cabeza de la pila.</li>
                                        <li>Entra en un bucle <code class="nombre-constante">while(1)</code> (bucle infinito controlado internamente).</li>
                                        <li>Incrementa <code class="nombre-tipo">size</code>.</li>
                                        <li>Avanza <code class="nombre-tipo">current</code> al siguiente nodo (<code class="nombre-campo">current->next</code>).</li>
                                        <li>Comprueba si <code class="nombre-tipo">current</code> ha vuelto a la cabeza (<code class="nombre-campo">current == stack</code>). Si es así, significa que ha recorrido toda la lista, y rompe el bucle.</li>
                                        <li>Retorna el valor final de <code class="nombre-tipo">size</code>.</li>
                                    </ol>
                                     <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int get_stack_size(t_stack_node *stack)
            {
                int             size;
                t_stack_node    *current;
            
                size = 0;
                if (!stack)
                    return (0);
                current = stack;
                while (1) // Loop indefinitely until we circle back
                {
                    size++;
                    current = current->next;
                    if (current == stack) // If we are back at the head node
                        break ;           // Exit the loop
                }
                return (size);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/stack/stack_utils_find.c</code> (7/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">find_smallest</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Encontrar y devolver un puntero al nodo con el <code class="nombre-campo">index</code> más pequeño dentro de la pila.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack</code>: Puntero a la cabeza de la pila a buscar.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *</code>: Puntero al nodo con el índice más pequeño encontrado.</li>
                                        <li><code class="nombre-constante">NULL</code>: Si la pila está vacía (<code class="nombre-constante">NULL</code>).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si la pila es <code class="nombre-constante">NULL</code>. Si lo es, retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>Inicializa un puntero <code class="nombre-tipo">smallest</code> a la cabeza de la pila (asume inicialmente que el primer nodo es el más pequeño).</li>
                                        <li>Inicializa un puntero <code class="nombre-tipo">current</code> al nodo siguiente a la cabeza.</li>
                                        <li>Itera a través de la pila circular (<code class="nombre-tipo">while (current != stack)</code>).</li>
                                        <li>En cada iteración, compara el <code class="nombre-campo">index</code> del nodo <code class="nombre-tipo">current</code> con el <code class="nombre-campo">index</code> del nodo <code class="nombre-tipo">smallest</code> actual.</li>
                                        <li>Si <code class="nombre-campo">current->index</code> es menor que <code class="nombre-campo">smallest->index</code>, actualiza <code class="nombre-tipo">smallest</code> para que apunte a <code class="nombre-tipo">current</code>.</li>
                                        <li>Avanza <code class="nombre-tipo">current</code> al siguiente nodo.</li>
                                        <li>Una vez recorrido toda la pila, retorna el puntero <code class="nombre-tipo">smallest</code> final.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">t_stack_node    *find_smallest(t_stack_node *stack)
            {
                t_stack_node    *smallest;
                t_stack_node    *current;
            
                if (!stack)
                    return (NULL);
                smallest = stack;        // Assume head is smallest initially
                current = stack->next;   // Start checking from the next node
                while (current != stack) // Loop until we circle back to head
                {
                    if (current->index < smallest->index) // Compare indices
                        smallest = current; // Update if current is smaller
                    current = current->next; // Move to the next node
                }
                return (smallest); // Return the node found with the smallest index
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">find_largest</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Encontrar y devolver un puntero al nodo con el <code class="nombre-campo">index</code> más grande dentro de la pila.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack</code>: Puntero a la cabeza de la pila a buscar.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *</code>: Puntero al nodo con el índice más grande encontrado.</li>
                                        <li><code class="nombre-constante">NULL</code>: Si la pila está vacía (<code class="nombre-constante">NULL</code>).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si la pila es <code class="nombre-constante">NULL</code>. Si lo es, retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>Inicializa un puntero <code class="nombre-tipo">largest</code> a la cabeza de la pila (asume inicialmente que el primer nodo es el más grande).</li>
                                        <li>Inicializa un puntero <code class="nombre-tipo">current</code> al nodo siguiente a la cabeza.</li>
                                        <li>Itera a través de la pila circular (<code class="nombre-tipo">while (current != stack)</code>).</li>
                                        <li>En cada iteración, compara el <code class="nombre-campo">index</code> del nodo <code class="nombre-tipo">current</code> con el <code class="nombre-campo">index</code> del nodo <code class="nombre-tipo">largest</code> actual.</li>
                                        <li>Si <code class="nombre-campo">current->index</code> es mayor que <code class="nombre-campo">largest->index</code>, actualiza <code class="nombre-tipo">largest</code> para que apunte a <code class="nombre-tipo">current</code>.</li>
                                        <li>Avanza <code class="nombre-tipo">current</code> al siguiente nodo.</li>
                                        <li>Una vez recorrido toda la pila, retorna el puntero <code class="nombre-tipo">largest</code> final.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">t_stack_node    *find_largest(t_stack_node *stack)
            {
                t_stack_node    *largest;
                t_stack_node    *current;
            
                if (!stack)
                    return (NULL);
                largest = stack;         // Assume head is largest initially
                current = stack->next;    // Start checking from the next node
                while (current != stack)  // Loop until we circle back to head
                {
                    if (current->index > largest->index) // Compare indices
                        largest = current; // Update if current is larger
                    current = current->next; // Move to the next node
                }
                return (largest); // Return the node found with the largest index
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/sort.c</code> (8/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">push_initial_to_b</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Mover los dos primeros elementos de la <code class="nombre-pila">Pila A</code> a la <code class="nombre-pila">Pila B</code> si la <code class="nombre-pila">Pila A</code> tiene más de 3 elementos y no está ya ordenada. Esto simplifica el problema principal al reducir el tamaño de A y establecer una base en B.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal que contiene ambas pilas y sus tamaños.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si el tamaño de A (<code class="nombre-campo">s->size_a</code>) es mayor que 3 Y si la pila A no está ordenada (<code class="nombre-funcion">!is_sorted(s->a)</code>).</li>
                                        <li>Si ambas condiciones son verdaderas, ejecuta la operación <code class="nombre-operacion">pb</code> una vez (llamando a <code class="nombre-funcion">do_pb</code>).</li>
                                        <li>Vuelve a comprobar las mismas condiciones (el tamaño de A habrá disminuido en 1).</li>
                                        <li>Si ambas condiciones siguen siendo verdaderas, ejecuta <code class="nombre-operacion">pb</code> una segunda vez.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">is_sorted</code>, <code class="nombre-funcion">do_pb</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void push_initial_to_b(t_stacks *s)
            {
                // Push first element if size > 3 and not sorted
                if (s->size_a > 3 && !is_sorted(s->a))
                    do_pb(s, 1); // Execute pb and print the operation
                // Push second element if size still > 3 and not sorted
                if (s->size_a > 3 && !is_sorted(s->a))
                    do_pb(s, 1); // Execute pb and print the operation
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">turk_sort</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Implementar el núcleo del algoritmo "Turk" para ordenar pilas con más de 3 elementos.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Llama a <code class="nombre-funcion">push_initial_to_b</code> para mover los primeros 1 o 2 elementos a B si es necesario.</li>
                                        <li>Entra en un bucle que continúa mientras la <code class="nombre-pila">Pila A</code> tenga más de 3 elementos Y no esté ordenada. Dentro del bucle:
                                            <ul>
                                                <li>Actualiza las posiciones (<code class="nombre-campo">pos</code>) de todos los nodos en A y B (<code class="nombre-funcion">update_positions</code>).</li>
                                                <li>Calcula la posición objetivo en B (<code class="nombre-campo">target_pos</code>) para cada nodo en A (<code class="nombre-funcion">assign_target_pos_b</code>).</li>
                                                <li>Calcula los costes de rotación (<code class="nombre-campo">cost_a</code>, <code class="nombre-campo">cost_b</code>) para mover cada nodo de A a su posición objetivo en B (<code class="nombre-funcion">calculate_cost_to_b</code>).</li>
                                                <li>Encuentra y ejecuta las rotaciones necesarias para mover el nodo de A con el coste combinado más bajo a la cima de A y su objetivo a la cima de B, y luego lo empuja a B (<code class="nombre-funcion">move_cheapest_to_b</code>).</li>
                                            </ul>
                                        </li>
                                        <li>Una vez que A tiene 3 elementos o menos (o se ordena), sale del bucle.</li>
                                        <li>Llama a <code class="nombre-funcion">sort_three</code> para ordenar los 3 elementos restantes en A.</li>
                                        <li>Llama a <code class="nombre-funcion">move_all_to_a</code> para devolver todos los elementos de B a A, insertándolos en la posición correcta.</li>
                                        <li>Llama a <code class="nombre-funcion">final_sort_a</code> para rotar A hasta que el elemento más pequeño (índice 0) esté en la cima.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">push_initial_to_b</code>, <code class="nombre-funcion">is_sorted</code>, <code class="nombre-funcion">update_positions</code>, <code class="nombre-funcion">assign_target_pos_b</code>, <code class="nombre-funcion">calculate_cost_to_b</code>, <code class="nombre-funcion">move_cheapest_to_b</code>, <code class="nombre-funcion">sort_three</code>, <code class="nombre-funcion">move_all_to_a</code>, <code class="nombre-funcion">final_sort_a</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void turk_sort(t_stacks *s)
            {
                // 1. Push initial elements to B to simplify A
                push_initial_to_b(s);
            
                // 2. Main loop: Push elements from A to B based on cost until A has 3
                while (s->size_a > 3 && !is_sorted(s->a))
                {
                    // Update current state (positions are crucial for cost calculation)
                    update_positions(s->a);
                    update_positions(s->b);
                    // For each node in A, find its target position in B
                    assign_target_pos_b(s);
                    // Calculate the rotation costs to move each A node to its target in B
                    calculate_cost_to_b(s);
                    // Find the node in A with the cheapest combined move cost and execute it
                    move_cheapest_to_b(s);
                }
            
                // 3. Sort the remaining 3 elements in A
                sort_three(s);
            
                // 4. Move all elements back from B to A in the correct order
                move_all_to_a(s);
            
                // 5. Final rotation of A to place the smallest element (index 0) at the top
                final_sort_a(s);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">sort_stack</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Función principal de alto nivel que decide qué algoritmo de ordenación aplicar según el tamaño inicial de la <code class="nombre-pila">Pila A</code>.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Realiza comprobaciones iniciales: si <code class="nombre-struct">stacks</code> o <code class="nombre-campo">stacks->a</code> es <code class="nombre-constante">NULL</code>, si el tamaño de A es 1 o menos, o si la pila ya está ordenada (<code class="nombre-funcion">is_sorted</code>), no hace nada y retorna.</li>
                                        <li>Si el tamaño de A es exactamente 2, solo necesita una operación <code class="nombre-operacion">sa</code> (llamando a <code class="nombre-funcion">do_sa</code>) para ordenarla.</li>
                                        <li>Si el tamaño de A es exactamente 3, llama a la función especializada <code class="nombre-funcion">sort_three</code>.</li>
                                        <li>Si el tamaño de A es mayor que 3, llama a la función <code class="nombre-funcion">turk_sort</code> que implementa el algoritmo principal.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">is_sorted</code>, <code class="nombre-funcion">do_sa</code>, <code class="nombre-funcion">sort_three</code>, <code class="nombre-funcion">turk_sort</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    sort_stack(t_stacks *stacks)
            {
                // Base cases: no need to sort if NULL, size <= 1, or already sorted
                if (!stacks || !stacks->a || stacks->size_a <= 1 || is_sorted(stacks->a))
                    return ;
            
                // Handle small stack sizes with specific, efficient sorts
                if (stacks->size_a == 2)
                    do_sa(stacks, 1); // Sort size 2 with a single swap if needed
                else if (stacks->size_a == 3)
                    sort_three(stacks); // Use the dedicated sort_three function
                else // For larger stacks, use the main Turk algorithm
                    turk_sort(stacks);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/sort_utils.c</code> (9/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">update_positions</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Recorrer una pila y asignar a cada nodo su posición actual (0 para el nodo superior, 1 para el siguiente, etc.) en el campo <code class="nombre-campo">pos</code>.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack</code>: Puntero a la cabeza de la pila a actualizar.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si la pila es <code class="nombre-constante">NULL</code>. Si lo es, retorna.</li>
                                        <li>Inicializa un puntero <code class="nombre-tipo">current</code> a la cabeza y un contador <code class="nombre-tipo">i</code> a 0.</li>
                                        <li>Entra en un bucle <code class="nombre-constante">while(1)</code>.</li>
                                        <li>Asigna el valor actual de <code class="nombre-tipo">i</code> al campo <code class="nombre-campo">pos</code> del nodo <code class="nombre-tipo">current</code> y luego incrementa <code class="nombre-tipo">i</code>.</li>
                                        <li>Avanza <code class="nombre-tipo">current</code> al siguiente nodo.</li>
                                        <li>Comprueba si <code class="nombre-tipo">current</code> ha vuelto a la cabeza. Si es así, rompe el bucle.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    update_positions(t_stack_node *stack)
            {
                t_stack_node    *current;
                int             i;
            
                if (!stack)
                    return ;
                current = stack;
                i = 0;
                while (1) // Loop through the circular list
                {
                    current->pos = i++; // Assign current position and increment
                    current = current->next; // Move to the next node
                    if (current == stack) // Stop when we return to the head
                        break ;
                }
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">find_best_target_a</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Función auxiliar para <code class="nombre-funcion">get_target_pos_in_a</code>. Busca en la <code class="nombre-pila">Pila A</code> el índice (<code class="nombre-campo">index</code>) más pequeño que sea estrictamente mayor que un índice dado de la <code class="nombre-pila">Pila B</code> (<code class="nombre-tipo">b_idx</code>), pero menor que el índice objetivo actual (<code class="nombre-tipo">cur_tgt_idx</code>).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *a</code>: Puntero a la cabeza de la <code class="nombre-pila">Pila A</code>.</li>
                                        <li><code class="nombre-tipo">int b_idx</code>: El índice del nodo de la <code class="nombre-pila">Pila B</code> para el cual se busca objetivo.</li>
                                        <li><code class="nombre-tipo">int cur_tgt_idx</code>: El índice objetivo encontrado hasta ahora (inicialmente <code class="nombre-constante">INT_MAX</code>).</li>
                                    </ul>
                                     <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                       <li><code class="nombre-tipo">int</code>: El índice (<code class="nombre-campo">index</code>) del mejor nodo objetivo encontrado en A, o <code class="nombre-constante">INT_MAX</code> si no se encontró ninguno que cumpla la condición.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Inicializa <code class="nombre-tipo">current_a</code> a la cabeza de A.</li>
                                        <li>Itera sobre la <code class="nombre-pila">Pila A</code>.</li>
                                        <li>Para cada nodo <code class="nombre-tipo">current_a</code>, comprueba si su índice es mayor que <code class="nombre-tipo">b_idx</code> Y menor que el <code class="nombre-tipo">cur_tgt_idx</code> actual.</li>
                                        <li>Si ambas condiciones son ciertas, significa que este nodo es un mejor candidato (más cercano a <code class="nombre-tipo">b_idx</code> pero aún mayor), así que actualiza <code class="nombre-tipo">cur_tgt_idx</code> al índice de <code class="nombre-tipo">current_a</code>.</li>
                                        <li>Continúa hasta recorrer toda la pila A.</li>
                                        <li>Retorna el valor final de <code class="nombre-tipo">cur_tgt_idx</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static int  find_best_target_a(t_stack_node *a, int b_idx, int cur_tgt_idx)
            {
                t_stack_node    *current_a;
            
                current_a = a;
                while (1) // Loop through stack A
                {
                    // Check if current A node's index is greater than B's index
                    // AND smaller than the current best target index found so far
                    if (current_a->index > b_idx && current_a->index < cur_tgt_idx)
                    {
                        // If yes, this node is a better target (closer to b_idx)
                        cur_tgt_idx = current_a->index;
                    }
                    current_a = current_a->next; // Move to next node in A
                    if (current_a == a) // Stop when we loop back to head
                        break ;
                }
                // Return the index of the best target found (or INT_MAX if none found)
                return (cur_tgt_idx);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">get_target_pos_in_a</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Calcular la posición (<code class="nombre-campo">pos</code>) objetivo ideal en la <code class="nombre-pila">Pila A</code> para un nodo que proviene de la <code class="nombre-pila">Pila B</code> con un índice específico (<code class="nombre-tipo">index_b</code>).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack_a</code>: Puntero a la cabeza de la <code class="nombre-pila">Pila A</code>.</li>
                                         <li><code class="nombre-tipo">int index_b</code>: El índice del nodo de la <code class="nombre-pila">Pila B</code> que se quiere mover a A.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int</code>: La posición (<code class="nombre-campo">pos</code>) del nodo objetivo en la <code class="nombre-pila">Pila A</code>.</li>
                                        <li><code class="nombre-constante">-1</code>: Si la <code class="nombre-pila">Pila A</code> está vacía o si ocurre algún error inesperado al encontrar el nodo.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-tipo">stack_a</code> es <code class="nombre-constante">NULL</code>. Si es así, retorna -1.</li>
                                        <li>Inicializa <code class="nombre-tipo">target_idx</code> a <code class="nombre-constante">INT_MAX</code>.</li>
                                        <li>Llama a <code class="nombre-funcion">find_best_target_a</code> para encontrar el índice del nodo en A que sea el más pequeño pero aún mayor que <code class="nombre-tipo">index_b</code>. El resultado se guarda de nuevo en <code class="nombre-tipo">target_idx</code>.</li>
                                        <li>Si <code class="nombre-tipo">target_idx</code> sigue siendo <code class="nombre-constante">INT_MAX</code>, significa que no se encontró ningún nodo en A con índice mayor que <code class="nombre-tipo">index_b</code> (es decir, <code class="nombre-tipo">index_b</code> es mayor que todos los índices en A). En este caso, el objetivo es el nodo con el índice más pequeño en A. Se llama a <code class="nombre-funcion">find_smallest</code> para encontrar este nodo.</li>
                                        <li>Si <code class="nombre-tipo">target_idx</code> tiene un valor diferente de <code class="nombre-constante">INT_MAX</code>, significa que se encontró un objetivo. Se busca el nodo correspondiente a ese <code class="nombre-tipo">target_idx</code> usando <code class="nombre-funcion">find_node_with_index</code> (función asumida, no mostrada en este archivo).</li>
                                        <li>Si se encontró un <code class="nombre-tipo">target_node</code> (ya sea el más pequeño o el encontrado por índice), retorna su posición (<code class="nombre-campo">target_node->pos</code>).</li>
                                        <li>Si por alguna razón no se encontró un <code class="nombre-tipo">target_node</code>, retorna -1.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">find_best_target_a</code>, <code class="nombre-funcion">find_smallest</code>, <code class="nombre-funcion">find_node_with_index</code> (asumida).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int get_target_pos_in_a(t_stack_node *stack_a, int index_b)
            {
                int             target_idx;
                t_stack_node    *target_node;
            
                if (!stack_a)
                    return (-1); // Cannot find target in empty stack
            
                // 1. Find the index of the smallest node in A that is > index_b
                target_idx = INT_MAX; // Initialize target index to maximum possible value
                target_idx = find_best_target_a(stack_a, index_b, target_idx);
            
                // 2. If no node in A is > index_b (target_idx is still INT_MAX)
                if (target_idx == INT_MAX)
                {
                    // The target becomes the node with the absolute smallest index in A
                    target_node = find_smallest(stack_a);
                }
                else // 3. If a target index was found
                {
                    // Find the node in A that has the target_idx
                    // (Assuming find_node_with_index exists and works)
                    target_node = find_node_with_index(stack_a, target_idx);
                }
            
                // 4. Return the position of the found target node
                if (target_node)
                    return (target_node->pos);
            
                return (-1); // Should ideally not happen if stack_a is not empty
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">find_best_target_b</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Función auxiliar para <code class="nombre-funcion">get_target_pos_in_b</code>. Busca en la <code class="nombre-pila">Pila B</code> el índice (<code class="nombre-campo">index</code>) más grande que sea estrictamente menor que un índice dado de la <code class="nombre-pila">Pila A</code> (<code class="nombre-tipo">a_idx</code>), pero mayor que el índice objetivo actual (<code class="nombre-tipo">cur_tgt_idx</code>).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *b</code>: Puntero a la cabeza de la <code class="nombre-pila">Pila B</code>.</li>
                                        <li><code class="nombre-tipo">int a_idx</code>: El índice del nodo de la <code class="nombre-pila">Pila A</code> para el cual se busca objetivo.</li>
                                        <li><code class="nombre-tipo">int cur_tgt_idx</code>: El índice objetivo encontrado hasta ahora (inicialmente <code class="nombre-constante">INT_MIN</code>).</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int</code>: El índice (<code class="nombre-campo">index</code>) del mejor nodo objetivo encontrado en B, o <code class="nombre-constante">INT_MIN</code> si no se encontró ninguno que cumpla la condición.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Inicializa <code class="nombre-tipo">current_b</code> a la cabeza de B.</li>
                                        <li>Itera sobre la <code class="nombre-pila">Pila B</code>.</li>
                                        <li>Para cada nodo <code class="nombre-tipo">current_b</code>, comprueba si su índice es menor que <code class="nombre-tipo">a_idx</code> Y mayor que el <code class="nombre-tipo">cur_tgt_idx</code> actual.</li>
                                        <li>Si ambas condiciones son ciertas, significa que este nodo es un mejor candidato (más cercano a <code class="nombre-tipo">a_idx</code> pero aún menor), así que actualiza <code class="nombre-tipo">cur_tgt_idx</code> al índice de <code class="nombre-tipo">current_b</code>.</li>
                                        <li>Continúa hasta recorrer toda la pila B.</li>
                                        <li>Retorna el valor final de <code class="nombre-tipo">cur_tgt_idx</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static int  find_best_target_b(t_stack_node *b, int a_idx, int cur_tgt_idx)
            {
                t_stack_node    *current_b;
            
                current_b = b;
                while (1) // Loop through stack B
                {
                    // Check if current B node's index is smaller than A's index
                    // AND larger than the current best target index found so far
                    if (current_b->index < a_idx && current_b->index > cur_tgt_idx)
                    {
                        // If yes, this node is a better target (closer to a_idx)
                        cur_tgt_idx = current_b->index;
                    }
                    current_b = current_b->next; // Move to next node in B
                    if (current_b == b) // Stop when we loop back to head
                        break ;
                }
                // Return the index of the best target found (or INT_MIN if none found)
                return (cur_tgt_idx);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">get_target_pos_in_b</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Calcular la posición (<code class="nombre-campo">pos</code>) objetivo ideal en la <code class="nombre-pila">Pila B</code> para un nodo que proviene de la <code class="nombre-pila">Pila A</code> con un índice específico (<code class="nombre-tipo">index_a</code>).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack_b</code>: Puntero a la cabeza de la <code class="nombre-pila">Pila B</code>.</li>
                                        <li><code class="nombre-tipo">int index_a</code>: El índice del nodo de la <code class="nombre-pila">Pila A</code> que se quiere mover a B.</li>
                                    </ul>
                                     <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int</code>: La posición (<code class="nombre-campo">pos</code>) del nodo objetivo en la <code class="nombre-pila">Pila B</code>.</li>
                                        <li><code class="nombre-constante">-1</code>: Si la <code class="nombre-pila">Pila B</code> está vacía o si ocurre algún error inesperado al encontrar el nodo.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                         <li>Comprueba si <code class="nombre-tipo">stack_b</code> es <code class="nombre-constante">NULL</code>. Si es así, retorna -1.</li>
                                        <li>Inicializa <code class="nombre-tipo">target_idx</code> a <code class="nombre-constante">INT_MIN</code>.</li>
                                        <li>Llama a <code class="nombre-funcion">find_best_target_b</code> para encontrar el índice del nodo en B que sea el más grande pero aún menor que <code class="nombre-tipo">index_a</code>. El resultado se guarda de nuevo en <code class="nombre-tipo">target_idx</code>.</li>
                                        <li>Si <code class="nombre-tipo">target_idx</code> sigue siendo <code class="nombre-constante">INT_MIN</code>, significa que no se encontró ningún nodo en B con índice menor que <code class="nombre-tipo">index_a</code> (es decir, <code class="nombre-tipo">index_a</code> es menor que todos los índices en B). En este caso, el objetivo es el nodo con el índice más grande en B. Se llama a <code class="nombre-funcion">find_largest</code> para encontrar este nodo.</li>
                                        <li>Si <code class="nombre-tipo">target_idx</code> tiene un valor diferente de <code class="nombre-constante">INT_MIN</code>, significa que se encontró un objetivo. Se busca el nodo correspondiente a ese <code class="nombre-tipo">target_idx</code> usando <code class="nombre-funcion">find_node_with_index</code> (asumida).</li>
                                        <li>Si se encontró un <code class="nombre-tipo">target_node</code> (ya sea el más grande o el encontrado por índice), retorna su posición (<code class="nombre-campo">target_node->pos</code>).</li>
                                        <li>Si por alguna razón no se encontró un <code class="nombre-tipo">target_node</code>, retorna -1.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">find_best_target_b</code>, <code class="nombre-funcion">find_largest</code>, <code class="nombre-funcion">find_node_with_index</code> (asumida).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int get_target_pos_in_b(t_stack_node *stack_b, int index_a)
            {
                int             target_idx;
                t_stack_node    *target_node;
            
                if (!stack_b)
                    return (-1); // Cannot find target in empty stack
            
                // 1. Find the index of the largest node in B that is < index_a
                target_idx = INT_MIN; // Initialize target index to minimum possible value
                target_idx = find_best_target_b(stack_b, index_a, target_idx);
            
                // 2. If no node in B is < index_a (target_idx is still INT_MIN)
                if (target_idx == INT_MIN)
                {
                    // The target becomes the node with the absolute largest index in B
                    target_node = find_largest(stack_b);
                }
                else // 3. If a target index was found
                {
                    // Find the node in B that has the target_idx
                    // (Assuming find_node_with_index exists and works)
                    target_node = find_node_with_index(stack_b, target_idx);
                }
            
                // 4. Return the position of the found target node
                if (target_node)
                    return (target_node->pos);
            
                return (-1); // Should ideally not happen if stack_b is not empty
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/sort_utils_moves.c</code> (10/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">calculate_combined_cost</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Calcular el coste total estimado de mover un nodo de A a B, teniendo en cuenta la posibilidad de realizar rotaciones simultáneas (<code class="nombre-operacion">rr</code> o <code class="nombre-operacion">rrr</code>) si los costes individuales (<code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code>) tienen el mismo signo.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int cost_a</code>: El coste de rotación calculado para la <code class="nombre-pila">Pila A</code> (positivo para <code class="nombre-operacion">ra</code>, negativo para <code class="nombre-operacion">rra</code>).</li>
                                        <li><code class="nombre-tipo">int cost_b</code>: El coste de rotación calculado para la <code class="nombre-pila">Pila B</code> (positivo para <code class="nombre-operacion">rb</code>, negativo para <code class="nombre-operacion">rrb</code>).</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int</code>: El coste combinado estimado. Representa el número total de operaciones de rotación individuales necesarias.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Si ambos costes son positivos o cero (<code class="nombre-operacion">ra</code> y <code class="nombre-operacion">rb</code>): El coste combinado es el máximo de los dos (porque las rotaciones comunes se hacen con <code class="nombre-operacion">rr</code>, y las restantes individualmente).</li>
                                        <li>Si ambos costes son negativos o cero (<code class="nombre-operacion">rra</code> y <code class="nombre-operacion">rrb</code>): El coste combinado es el máximo de los valores absolutos de los dos (porque las rotaciones inversas comunes se hacen con <code class="nombre-operacion">rrr</code>, y las restantes individualmente).</li>
                                        <li>Si los costes tienen signos diferentes (uno positivo y otro negativo): No se pueden combinar rotaciones. El coste total es la suma de los valores absolutos de ambos costes (rotaciones individuales en cada pila).</li>
                                        <li>Retorna el coste calculado.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">abs_val</code> (asumida, probablemente una macro o función simple para valor absoluto).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static int  calculate_combined_cost(int cost_a, int cost_b)
            {
                int cost;
            
                // Case 1: Both costs are positive (ra and rb)
                if (cost_a >= 0 && cost_b >= 0)
                {
                    // Combined cost is the max, as 'rr' covers the minimum
                    if (cost_a > cost_b)
                        cost = cost_a;
                    else
                        cost = cost_b;
                }
                // Case 2: Both costs are negative (rra and rrb)
                else if (cost_a <= 0 && cost_b <= 0)
                {
                    // Combined cost is the max of absolute values, as 'rrr' covers the minimum
                    if (abs_val(cost_a) > abs_val(cost_b)) // Assuming abs_val() exists
                        cost = abs_val(cost_a);
                    else
                        cost = abs_val(cost_b);
                }
                // Case 3: Costs have different signs (no combined moves possible)
                else
                {
                    // Total cost is the sum of individual (absolute) costs
                    cost = abs_val(cost_a) + abs_val(cost_b);
                }
                return (cost);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">find_cheapest_node</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Encontrar el nodo en la <code class="nombre-pila">Pila A</code> que tiene el coste combinado más bajo para ser movido a la <code class="nombre-pila">Pila B</code>.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *</code>: Puntero al nodo de A con el menor coste combinado.</li>
                                         <li><code class="nombre-constante">NULL</code>: Si la estructura <code class="nombre-struct">stacks</code> o la <code class="nombre-pila">Pila A</code> están vacías.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-struct">stacks</code> o <code class="nombre-campo">stacks->a</code> son <code class="nombre-constante">NULL</code>.</li>
                                        <li>Inicializa <code class="nombre-tipo">cheapest_node</code> a la cabeza de A y <code class="nombre-tipo">cheapest_cost</code> a <code class="nombre-constante">INT_MAX</code>.</li>
                                        <li>Itera sobre la <code class="nombre-pila">Pila A</code> (<code class="nombre-tipo">current_a</code>).</li>
                                        <li>Para cada nodo, calcula su coste combinado usando <code class="nombre-funcion">calculate_combined_cost</code> con sus campos <code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code> (previamente calculados por <code class="nombre-funcion">calculate_cost_to_b</code>).</li>
                                        <li>Si el <code class="nombre-tipo">current_cost</code> es menor que el <code class="nombre-tipo">cheapest_cost</code> encontrado hasta ahora, actualiza <code class="nombre-tipo">cheapest_cost</code> y <code class="nombre-tipo">cheapest_node</code>.</li>
                                        <li>Continúa hasta recorrer toda la pila.</li>
                                        <li>Retorna el <code class="nombre-tipo">cheapest_node</code> encontrado.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">calculate_combined_cost</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">t_stack_node    *find_cheapest_node(t_stacks *stacks)
            {
                t_stack_node    *cheapest_node;
                t_stack_node    *current_a;
                int             cheapest_cost;
                int             current_cost;
            
                if (!stacks || !stacks->a)
                    return (NULL); // Cannot find cheapest in empty stack
            
                cheapest_node = stacks->a; // Assume head is cheapest initially
                current_a = stacks->a;
                cheapest_cost = INT_MAX; // Initialize cheapest cost to max value
            
                while (1) // Loop through stack A
                {
                    // Calculate combined cost for the current node
                    current_cost = calculate_combined_cost(current_a->cost_a,
                                                            current_a->cost_b);
                    // If this node's cost is lower than the current minimum
                    if (current_cost < cheapest_cost)
                    {
                        cheapest_cost = current_cost; // Update minimum cost
                        cheapest_node = current_a;    // Update cheapest node pointer
                    }
                    current_a = current_a->next; // Move to next node
                    if (current_a == stacks->a) // Stop when we loop back to head
                        break ;
                }
                return (cheapest_node); // Return the node with the overall lowest cost
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">move_cheapest_to_b</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Identificar el nodo más "barato" para mover de A a B, ejecutar las rotaciones necesarias en ambas pilas para llevarlo a él y a su objetivo a la cima, y finalmente empujar el nodo de A a B.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                       <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Llama a <code class="nombre-funcion">find_cheapest_node</code> para obtener un puntero al nodo de A con el menor coste combinado.</li>
                                        <li>Si se encontró un nodo (<code class="nombre-tipo">cheapest != NULL</code>):
                                            <ul>
                                                <li>Llama a <code class="nombre-funcion">execute_rotations</code> (función asumida, definida en otro archivo) pasándole los costes <code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code> del nodo <code class="nombre-tipo">cheapest</code>. Esta función se encarga de realizar las operaciones <code class="nombre-operacion">ra</code>, <code class="nombre-operacion">rb</code>, <code class="nombre-operacion">rr</code>, <code class="nombre-operacion">rra</code>, <code class="nombre-operacion">rrb</code>, <code class="nombre-operacion">rrr</code> necesarias.</li>
                                                <li>Llama a <code class="nombre-funcion">do_pb</code> para empujar el nodo (que ahora está en la cima de A) a la <code class="nombre-pila">Pila B</code>.</li>
                                            </ul>
                                        </li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">find_cheapest_node</code>, <code class="nombre-funcion">execute_rotations</code> (asumida), <code class="nombre-funcion">do_pb</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    move_cheapest_to_b(t_stacks *s)
            {
                t_stack_node    *cheapest;
            
                // 1. Find the node in A that is cheapest to move to B
                cheapest = find_cheapest_node(s);
            
                if (cheapest) // If a cheapest node was found
                {
                    // 2. Execute the required rotations (ra, rb, rr, rra, rrb, rrr)
                    //    based on the pre-calculated costs stored in the node.
                    //    (Assuming execute_rotations handles positive/negative costs
                    //     and combined moves like rr/rrr).
                    execute_rotations(s, cheapest->cost_a, cheapest->cost_b);
            
                    // 3. Push the cheapest node (now at the top of A) to B
                    do_pb(s, 1);
                }
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">move_all_to_a</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Mover todos los elementos de la <code class="nombre-pila">Pila B</code> de vuelta a la <code class="nombre-pila">Pila A</code>, asegurándose de que cada elemento se inserte en la posición correcta en A.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Entra en un bucle que continúa mientras la <code class="nombre-pila">Pila B</code> tenga elementos (<code class="nombre-campo">s->size_b > 0</code>).</li>
                                        <li>Dentro del bucle:
                                            <ul>
                                                <li>Actualiza las posiciones en ambas pilas (<code class="nombre-funcion">update_positions</code>).</li>
                                                <li>Calcula la posición objetivo en A para cada nodo de B (<code class="nombre-funcion">assign_target_pos_a</code>). Esta función debe calcular y almacenar el <code class="nombre-campo">cost_a</code> necesario para llevar la posición objetivo a la cima de A.</li>
                                                <li>Obtiene un puntero al nodo superior de B (<code class="nombre-tipo">top_b = s->b</code>).</li>
                                                <li>Llama a <code class="nombre-funcion">rotate_a_to_top</code> (función asumida) pasándole la posición objetivo (<code class="nombre-campo">top_b->target_pos</code>) calculada en el paso anterior. Esta función ejecuta las <code class="nombre-operacion">ra</code> o <code class="nombre-operacion">rra</code> necesarias.</li>
                                                <li>Llama a <code class="nombre-funcion">do_pa</code> para empujar el nodo superior de B a A (que ahora está lista para recibirlo en la posición correcta).</li>
                                            </ul>
                                        </li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">update_positions</code>, <code class="nombre-funcion">assign_target_pos_a</code> (asumida), <code class="nombre-funcion">rotate_a_to_top</code> (asumida), <code class="nombre-funcion">do_pa</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    move_all_to_a(t_stacks *s)
            {
                t_stack_node    *top_b;
            
                // Loop until stack B is empty
                while (s->size_b > 0)
                {
                    // 1. Update positions and calculate target positions in A for B nodes
                    update_positions(s->a);
                    update_positions(s->b);
                    assign_target_pos_a(s); // Assumes this calculates target_pos for B nodes
            
                    // 2. Get the top node of B
                    top_b = s->b;
            
                    // 3. Rotate stack A so the target position for top_b is at the top
                    //    (Assuming rotate_a_to_top executes the necessary ra/rra)
                    rotate_a_to_top(s, top_b->target_pos);
            
                    // 4. Push the top element from B to A
                    do_pa(s, 1);
                }
            }</code></pre>
                                </div>
                            </details>
            
                             <details class="function-analysis">
                                <summary><code class="nombre-funcion">final_sort_a</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Realizar la rotación final de la <code class="nombre-pila">Pila A</code> para asegurar que el elemento con el índice más pequeño (índice 0) quede en la cima, completando así el ordenamiento.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                         <li>Comprueba si <code class="nombre-struct">s</code>, <code class="nombre-campo">s->a</code> son válidos y si la pila A ya está ordenada (<code class="nombre-funcion">is_sorted</code>). Si alguna de estas condiciones falla, retorna.</li>
                                        <li>Actualiza las posiciones de los nodos en A (<code class="nombre-funcion">update_positions</code>).</li>
                                        <li>Encuentra el nodo con el índice más pequeño (índice 0) usando <code class="nombre-funcion">find_smallest</code>.</li>
                                        <li>Llama a <code class="nombre-funcion">rotate_a_to_top</code> (función asumida) pasándole la posición (<code class="nombre-campo">pos</code>) del nodo más pequeño encontrado. Esta función ejecutará las <code class="nombre-operacion">ra</code> o <code class="nombre-operacion">rra</code> necesarias para llevar ese nodo a la cima.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">is_sorted</code>, <code class="nombre-funcion">update_positions</code>, <code class="nombre-funcion">find_smallest</code>, <code class="nombre-funcion">rotate_a_to_top</code> (asumida).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    final_sort_a(t_stacks *s)
            {
                t_stack_node    *smallest;
            
                // No need to sort if NULL, empty, or already sorted
                if (!s || !s->a || is_sorted(s->a))
                    return ;
            
                // 1. Ensure positions are up-to-date
                update_positions(s->a);
            
                // 2. Find the node with the smallest index (index 0)
                smallest = find_smallest(s->a);
            
                // 3. Rotate stack A until the smallest node is at the top
                //    (Assuming rotate_a_to_top executes the necessary ra/rra)
                rotate_a_to_top(s, smallest->pos);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/sort_utils_moves_helpers.c</code> (11/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">execute_rr_rrr</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar operaciones de rotación combinadas (<code class="nombre-operacion">rr</code> o <code class="nombre-operacion">rrr</code>) mientras los costes para ambas pilas (<code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code>) tengan el mismo signo y sean distintos de cero. Modifica los costes restantes por referencia.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int *cost_a</code>: Puntero al coste restante para la <code class="nombre-pila">Pila A</code>.</li>
                                        <li><code class="nombre-tipo">int *cost_b</code>: Puntero al coste restante para la <code class="nombre-pila">Pila B</code>.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Primer bucle: Mientras <code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code> sean ambos <strong>positivos</strong>:
                                            <ul>
                                                <li>Ejecuta <code class="nombre-operacion">rr</code> (llamando a <code class="nombre-funcion">do_rr</code>).</li>
                                                <li>Decrementa ambos costes (<code class="nombre-campo">*cost_a</code> y <code class="nombre-campo">*cost_b</code>).</li>
                                            </ul>
                                        </li>
                                         <li>Segundo bucle: Mientras <code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code> sean ambos <strong>negativos</strong>:
                                            <ul>
                                                <li>Ejecuta <code class="nombre-operacion">rrr</code> (llamando a <code class="nombre-funcion">do_rrr</code>).</li>
                                                <li>Incrementa ambos costes (<code class="nombre-campo">*cost_a</code> y <code class="nombre-campo">*cost_b</code>), acercándolos a cero.</li>
                                            </ul>
                                        </li>
                                        <li>Al salir, los punteros <code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code> contendrán los costes de rotación individuales restantes (si alguno quedó).</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">do_rr</code>, <code class="nombre-funcion">do_rrr</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void execute_rr_rrr(t_stacks *s, int *cost_a, int *cost_b)
            {
                // Execute 'rr' while both costs are positive
                while (*cost_a > 0 && *cost_b > 0)
                {
                    do_rr(s, 1); // Perform combined rotate A and B
                    (*cost_a)--; // Decrement remaining cost for A
                    (*cost_b)--; // Decrement remaining cost for B
                }
                // Execute 'rrr' while both costs are negative
                while (*cost_a < 0 && *cost_b < 0)
                {
                    do_rrr(s, 1); // Perform combined reverse rotate A and B
                    (*cost_a)++; // Increment remaining cost for A (towards 0)
                    (*cost_b)++; // Increment remaining cost for B (towards 0)
                }
                // At this point, at least one of the costs (or both) is zero,
                // or they have different signs. The remaining cost values are updated.
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">execute_single_rotations</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar las operaciones de rotación individuales restantes (<code class="nombre-operacion">ra</code>, <code class="nombre-operacion">rra</code>, <code class="nombre-operacion">rb</code>, <code class="nombre-operacion">rrb</code>) después de haber realizado las rotaciones combinadas posibles.</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int cost_a</code>: El coste restante para la <code class="nombre-pila">Pila A</code> (después de <code class="nombre-funcion">execute_rr_rrr</code>).</li>
                                        <li><code class="nombre-tipo">int cost_b</code>: El coste restante para la <code class="nombre-pila">Pila B</code> (después de <code class="nombre-funcion">execute_rr_rrr</code>).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Primer bucle: Mientras <code class="nombre-campo">cost_a</code> sea positivo, ejecuta <code class="nombre-operacion">ra</code> y decrementa <code class="nombre-campo">cost_a</code>.</li>
                                        <li>Segundo bucle: Mientras <code class="nombre-campo">cost_a</code> sea negativo, ejecuta <code class="nombre-operacion">rra</code> e incrementa <code class="nombre-campo">cost_a</code> (hacia cero).</li>
                                         <li>Tercer bucle: Mientras <code class="nombre-campo">cost_b</code> sea positivo, ejecuta <code class="nombre-operacion">rb</code> y decrementa <code class="nombre-campo">cost_b</code>.</li>
                                        <li>Cuarto bucle: Mientras <code class="nombre-campo">cost_b</code> sea negativo, ejecuta <code class="nombre-operacion">rrb</code> e incrementa <code class="nombre-campo">cost_b</code> (hacia cero).</li>
                                    </ol>
                                     <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">do_ra</code>, <code class="nombre-funcion">do_rra</code>, <code class="nombre-funcion">do_rb</code>, <code class="nombre-funcion">do_rrb</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void execute_single_rotations(t_stacks *s, int cost_a, int cost_b)
            {
                // Execute remaining 'ra' operations
                while (cost_a > 0)
                {
                    do_ra(s, 1);
                    cost_a--;
                }
                // Execute remaining 'rra' operations
                while (cost_a < 0)
                {
                    do_rra(s, 1);
                    cost_a++;
                }
                // Execute remaining 'rb' operations
                while (cost_b > 0)
                {
                    do_rb(s, 1);
                    cost_b--;
                }
                // Execute remaining 'rrb' operations
                while (cost_b < 0)
                {
                    do_rrb(s, 1);
                    cost_b++;
                }
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">execute_rotations</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Orquestar la ejecución de todas las rotaciones necesarias basadas en los costes calculados <code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code>, priorizando las rotaciones combinadas.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int cost_a</code>: El coste total calculado para la <code class="nombre-pila">Pila A</code>.</li>
                                        <li><code class="nombre-tipo">int cost_b</code>: El coste total calculado para la <code class="nombre-pila">Pila B</code>.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Llama a <code class="nombre-funcion">execute_rr_rrr</code>, pasando las direcciones de <code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code> para que puedan ser modificadas. Esta función ejecuta todas las <code class="nombre-operacion">rr</code> y <code class="nombre-operacion">rrr</code> posibles.</li>
                                         <li>Llama a <code class="nombre-funcion">execute_single_rotations</code> con los valores actualizados de <code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code> (que ahora representan solo las rotaciones individuales restantes). Esta función ejecuta las <code class="nombre-operacion">ra</code>/<code class="nombre-operacion">rra</code>/<code class="nombre-operacion">rb</code>/<code class="nombre-operacion">rrb</code> que queden.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">execute_rr_rrr</code>, <code class="nombre-funcion">execute_single_rotations</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    execute_rotations(t_stacks *s, int cost_a, int cost_b)
            {
                // 1. Execute combined rotations (rr and rrr) first.
                //    Pass costs by reference so they are updated with remaining values.
                execute_rr_rrr(s, &cost_a, &cost_b);
            
                // 2. Execute any remaining single rotations (ra, rra, rb, rrb).
                //    Use the updated cost values.
                execute_single_rotations(s, cost_a, cost_b);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">rotate_a_to_top</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Rotar la <code class="nombre-pila">Pila A</code> hasta que el nodo que se encuentra en la posición <code class="nombre-tipo">target_pos</code> llegue a la cima (posición 0), utilizando la dirección de rotación más corta (<code class="nombre-operacion">ra</code> o <code class="nombre-operacion">rra</code>).</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int target_pos</code>: La posición actual del nodo que se quiere llevar a la cima.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Si <code class="nombre-tipo">target_pos</code> es -1 (inválido), retorna.</li>
                                        <li>Obtiene el tamaño actual de la <code class="nombre-pila">Pila A</code> (<code class="nombre-tipo">size_a</code>).</li>
                                        <li>Calcula el coste de rotación (<code class="nombre-tipo">cost_a</code>):
                                            <ul>
                                                <li>Si <code class="nombre-tipo">target_pos</code> está en la primera mitad de la pila (incluyendo el medio si es par), el coste es simplemente <code class="nombre-tipo">target_pos</code> (número de <code class="nombre-operacion">ra</code>).</li>
                                                <li>Si <code class="nombre-tipo">target_pos</code> está en la segunda mitad, es más corto usar <code class="nombre-operacion">rra</code>. El coste se calcula como <code class="nombre-tipo">target_pos - size_a</code> (será un número negativo, indicando el número de <code class="nombre-operacion">rra</code>).</li>
                                            </ul>
                                        </li>
                                        <li>Primer bucle: Mientras <code class="nombre-tipo">cost_a</code> sea positivo, ejecuta <code class="nombre-operacion">ra</code> y decrementa <code class="nombre-tipo">cost_a</code>.</li>
                                         <li>Segundo bucle: Mientras <code class="nombre-tipo">cost_a</code> sea negativo, ejecuta <code class="nombre-operacion">rra</code> e incrementa <code class="nombre-tipo">cost_a</code> (hacia cero).</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">do_ra</code>, <code class="nombre-funcion">do_rra</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    rotate_a_to_top(t_stacks *s, int target_pos)
            {
                int cost_a;
                int size_a;
            
                if (target_pos == -1) // Invalid target position
                    return ;
            
                size_a = s->size_a; // Get current size of stack A
            
                // Calculate the shortest rotation cost (positive for ra, negative for rra)
                if (target_pos <= size_a / 2) // If target is in the first half (or middle)
                    cost_a = target_pos;      // Cost is the number of 'ra' needed
                else                          // If target is in the second half
                    cost_a = target_pos - size_a; // Cost is negative, representing 'rra'
            
                // Execute 'ra' rotations
                while (cost_a > 0)
                {
                    do_ra(s, 1);
                    cost_a--;
                }
                // Execute 'rra' rotations
                while (cost_a < 0)
                {
                    do_rra(s, 1);
                    cost_a++;
                }
                // Now the node originally at target_pos is at the top (pos 0)
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/sort_utils_helpers.c</code> (12/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">find_node_with_index</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Buscar y devolver un puntero al nodo dentro de una pila que tenga un <code class="nombre-campo">index</code> específico.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node *stack</code>: Puntero a la cabeza de la pila donde buscar.</li>
                                        <li><code class="nombre-tipo">int target_idx</code>: El valor del <code class="nombre-campo">index</code> que se está buscando.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                       <li><code class="nombre-tipo">t_stack_node *</code>: Puntero al nodo encontrado con el <code class="nombre-campo">index</code> igual a <code class="nombre-tipo">target_idx</code>.</li>
                                       <li><code class="nombre-constante">NULL</code>: Si la pila está vacía o si no se encuentra ningún nodo con ese índice.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si la pila es <code class="nombre-constante">NULL</code>. Si lo es, retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>Inicializa un puntero <code class="nombre-tipo">current</code> a la cabeza de la pila.</li>
                                        <li>Entra en un bucle <code class="nombre-constante">while(1)</code>.</li>
                                        <li>Comprueba si el <code class="nombre-campo">index</code> del nodo <code class="nombre-tipo">current</code> es igual a <code class="nombre-tipo">target_idx</code>. Si es así, retorna <code class="nombre-tipo">current</code> (nodo encontrado).</li>
                                        <li>Avanza <code class="nombre-tipo">current</code> al siguiente nodo.</li>
                                        <li>Comprueba si <code class="nombre-tipo">current</code> ha vuelto a la cabeza. Si es así, significa que se ha recorrido toda la pila sin encontrar el índice, y rompe el bucle.</li>
                                        <li>Si el bucle termina sin encontrar el nodo, retorna <code class="nombre-constante">NULL</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">t_stack_node    *find_node_with_index(t_stack_node *stack, int target_idx)
            {
                t_stack_node    *current;
            
                if (!stack)
                    return (NULL); // Cannot search in an empty stack
            
                current = stack; // Start from the head
                while (1) // Loop through the circular list
                {
                    // If the current node's index matches the target index
                    if (current->index == target_idx)
                        return (current); // Return pointer to this node
            
                    current = current->next; // Move to the next node
            
                    // If we have looped back to the start without finding the index
                    if (current == stack)
                        break ; // Exit the loop
                }
            
                // If the loop finishes without finding the node
                return (NULL);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/sort_utils_assign.c</code> (13/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">assign_target_pos_a</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Iterar sobre cada nodo de la <code class="nombre-pila">Pila B</code> y asignar a su campo <code class="nombre-campo">target_pos</code> la posición (<code class="nombre-campo">pos</code>) del nodo correspondiente en la <code class="nombre-pila">Pila A</code> donde debería insertarse.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal que contiene ambas pilas.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-struct">stacks</code> o <code class="nombre-campo">stacks->b</code> son <code class="nombre-constante">NULL</code>. Si es así, retorna.</li>
                                        <li>Inicializa <code class="nombre-tipo">current_b</code> a la cabeza de la <code class="nombre-pila">Pila B</code>.</li>
                                        <li>Actualiza las posiciones (<code class="nombre-campo">pos</code>) de los nodos en ambas pilas A y B usando <code class="nombre-funcion">update_positions</code>. Esto es crucial porque las posiciones pueden haber cambiado desde la última actualización.</li>
                                        <li>Entra en un bucle <code class="nombre-constante">while(1)</code> para recorrer la <code class="nombre-pila">Pila B</code>.</li>
                                        <li>Para cada nodo <code class="nombre-tipo">current_b</code>:
                                            <ul>
                                                <li>Llama a <code class="nombre-funcion">get_target_pos_in_a</code> pasando la <code class="nombre-pila">Pila A</code> y el <code class="nombre-campo">index</code> del nodo <code class="nombre-tipo">current_b</code>.</li>
                                                <li>El valor devuelto (la posición objetivo en A) se almacena en <code class="nombre-tipo">target_pos</code>.</li>
                                                <li>Asigna <code class="nombre-tipo">target_pos</code> al campo <code class="nombre-campo">current_b->target_pos</code>.</li>
                                            </ul>
                                        </li>
                                        <li>Avanza <code class="nombre-tipo">current_b</code> al siguiente nodo.</li>
                                        <li>Si <code class="nombre-tipo">current_b</code> vuelve a la cabeza de B, rompe el bucle.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">update_positions</code>, <code class="nombre-funcion">get_target_pos_in_a</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    assign_target_pos_a(t_stacks *stacks)
            {
                t_stack_node    *current_b;
                int             target_pos;
            
                if (!stacks || !stacks->b) // No B stack to assign targets for
                    return ;
            
                current_b = stacks->b; // Start from the head of B
            
                // Ensure current positions in both stacks are up-to-date
                update_positions(stacks->a);
                update_positions(stacks->b);
            
                // Loop through each node in stack B
                while (1)
                {
                    // Find the ideal target position in stack A for the current B node
                    target_pos = get_target_pos_in_a(stacks->a, current_b->index);
                    // Assign the found position to the B node's target_pos field
                    current_b->target_pos = target_pos;
            
                    current_b = current_b->next; // Move to the next node in B
                    if (current_b == stacks->b) // Stop if we've looped back to the head
                        break ;
                }
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">assign_target_pos_b</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Iterar sobre cada nodo de la <code class="nombre-pila">Pila A</code> y asignar a su campo <code class="nombre-campo">target_pos</code> la posición (<code class="nombre-campo">pos</code>) del nodo correspondiente en la <code class="nombre-pila">Pila B</code> donde debería insertarse.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal que contiene ambas pilas.</li>
                                    </ul>
                                     <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-struct">stacks</code> o <code class="nombre-campo">stacks->a</code> son <code class="nombre-constante">NULL</code>. Si es así, retorna.</li>
                                        <li>Inicializa <code class="nombre-tipo">current_a</code> a la cabeza de la <code class="nombre-pila">Pila A</code>.</li>
                                        <li>Actualiza las posiciones (<code class="nombre-campo">pos</code>) de los nodos en ambas pilas A y B usando <code class="nombre-funcion">update_positions</code>.</li>
                                        <li>Entra en un bucle <code class="nombre-constante">while(1)</code> para recorrer la <code class="nombre-pila">Pila A</code>.</li>
                                        <li>Para cada nodo <code class="nombre-tipo">current_a</code>:
                                            <ul>
                                                <li>Llama a <code class="nombre-funcion">get_target_pos_in_b</code> pasando la <code class="nombre-pila">Pila B</code> y el <code class="nombre-campo">index</code> del nodo <code class="nombre-tipo">current_a</code>.</li>
                                                <li>El valor devuelto (la posición objetivo en B) se almacena en <code class="nombre-tipo">target_pos</code>.</li>
                                                <li>Asigna <code class="nombre-tipo">target_pos</code> al campo <code class="nombre-campo">current_a->target_pos</code>.</li>
                                            </ul>
                                        </li>
                                        <li>Avanza <code class="nombre-tipo">current_a</code> al siguiente nodo.</li>
                                        <li>Si <code class="nombre-tipo">current_a</code> vuelve a la cabeza de A, rompe el bucle.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">update_positions</code>, <code class="nombre-funcion">get_target_pos_in_b</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    assign_target_pos_b(t_stacks *stacks)
            {
                t_stack_node    *current_a;
                int             target_pos;
            
                if (!stacks || !stacks->a) // No A stack to assign targets for
                    return ;
            
                current_a = stacks->a; // Start from the head of A
            
                // Ensure current positions in both stacks are up-to-date
                update_positions(stacks->a);
                update_positions(stacks->b);
            
                // Loop through each node in stack A
                while (1)
                {
                    // Find the ideal target position in stack B for the current A node
                    target_pos = get_target_pos_in_b(stacks->b, current_a->index);
                    // Assign the found position to the A node's target_pos field
                    current_a->target_pos = target_pos;
            
                    current_a = current_a->next; // Move to the next node in A
                    if (current_a == stacks->a) // Stop if we've looped back to the head
                        break ;
                }
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/sort_small.c</code> (14/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">sort_three</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ordenar eficientemente la <code class="nombre-pila">Pila A</code> cuando contiene exactamente tres elementos, utilizando un máximo de dos operaciones (<code class="nombre-operacion">sa</code>, <code class="nombre-operacion">ra</code>, <code class="nombre-operacion">rra</code>).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba condiciones iniciales: si <code class="nombre-struct">s</code> es <code class="nombre-constante">NULL</code>, si el tamaño de A no es 3, o si la pila ya está ordenada (<code class="nombre-funcion">is_sorted</code>), retorna sin hacer nada.</li>
                                        <li>Obtiene los índices (<code class="nombre-campo">index</code>) de los tres nodos: el superior (<code class="nombre-tipo">top_idx</code>), el del medio (<code class="nombre-tipo">mid_idx</code>) y el inferior (<code class="nombre-tipo">bot_idx</code>).</li>
                                        <li>Compara estos tres índices para determinar cuál de los 5 posibles casos desordenados se presenta. Los casos se nombran según el orden relativo de los índices (ej: 1-3-2 significa que el índice más pequeño está arriba, el más grande en medio y el intermedio abajo).</li>
                                        <li>Llama a una función auxiliar específica (<code class="nombre-funcion">handle_case_...</code>) para cada uno de los 5 casos desordenados. Cada una de estas funciones auxiliares (declaradas al principio del archivo pero definidas probablemente en otro lugar o más abajo) ejecutará la secuencia óptima de 1 o 2 operaciones para ordenar ese caso específico.
                                            <ul>
                                                <li>Caso 1-3-2 (<code class="nombre-constante">top < mid</code>, <code class="nombre-constante">mid > bot</code>, <code class="nombre-constante">top < bot</code>): Llama a <code class="nombre-funcion">handle_case_1_3_2</code> (probablemente <code class="nombre-operacion">rra</code>, <code class="nombre-operacion">sa</code>).</li>
                                                <li>Caso 2-1-3 (<code class="nombre-constante">top > mid</code>, <code class="nombre-constante">mid < bot</code>, <code class="nombre-constante">top < bot</code>): Llama a <code class="nombre-funcion">handle_case_2_1_3</code> (probablemente <code class="nombre-operacion">sa</code>).</li>
                                                <li>Caso 2-3-1 (<code class="nombre-constante">top < mid</code>, <code class="nombre-constante">mid > bot</code>, <code class="nombre-constante">top > bot</code>): Llama a <code class="nombre-funcion">handle_case_2_3_1</code> (probablemente <code class="nombre-operacion">rra</code>).</li>
                                                 <li>Caso 3-1-2 (<code class="nombre-constante">top > mid</code>, <code class="nombre-constante">mid < bot</code>, <code class="nombre-constante">top > bot</code>): Llama a <code class="nombre-funcion">handle_case_3_1_2</code> (probablemente <code class="nombre-operacion">ra</code>).</li>
                                                 <li>Caso 3-2-1 (<code class="nombre-constante">top > mid</code>, <code class="nombre-constante">mid > bot</code>): Llama a <code class="nombre-funcion">handle_case_3_2_1</code> (probablemente <code class="nombre-operacion">sa</code>, <code class="nombre-operacion">rra</code>).</li>
                                            </ul>
                                        </li>
                                         <li>El caso 1-2-3 (ya ordenado) se maneja con la comprobación inicial <code class="nombre-funcion">is_sorted</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">is_sorted</code>, <code class="nombre-funcion">handle_case_1_3_2</code>, <code class="nombre-funcion">handle_case_2_1_3</code>, <code class="nombre-funcion">handle_case_2_3_1</code>, <code class="nombre-funcion">handle_case_3_1_2</code>, <code class="nombre-funcion">handle_case_3_2_1</code> (estas últimas son declaradas aquí pero definidas en otro lugar, presumiblemente <code class="nombre-archivo">sort_small_cases.c</code>).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">// Forward declarations for case handlers (definitions likely elsewhere)
            void    handle_case_1_3_2(t_stacks *s);
            void    handle_case_2_1_3(t_stacks *s);
            void    handle_case_2_3_1(t_stacks *s);
            void    handle_case_3_1_2(t_stacks *s);
            void    handle_case_3_2_1(t_stacks *s);
            
            void    sort_three(t_stacks *s)
            {
                int top_idx;
                int mid_idx;
                int bot_idx;
            
                // Return if stack is NULL, not size 3, or already sorted
                if (!s || s->size_a != 3 || is_sorted(s->a))
                    return ;
            
                // Get the indices of the top, middle, and bottom elements
                top_idx = s->a->index;
                mid_idx = s->a->next->index;
                bot_idx = s->a->prev->index; // Bottom element in circular list
            
                // Determine the specific case based on index order and call handler
                // Case 1-3-2 (e.g., values 0, 2, 1)
                if (top_idx < mid_idx && mid_idx > bot_idx && top_idx < bot_idx)
                    handle_case_1_3_2(s);
                // Case 2-1-3 (e.g., values 1, 0, 2)
                else if (top_idx > mid_idx && mid_idx < bot_idx && top_idx < bot_idx)
                    handle_case_2_1_3(s);
                // Case 2-3-1 (e.g., values 1, 2, 0)
                else if (top_idx < mid_idx && mid_idx > bot_idx && top_idx > bot_idx)
                    handle_case_2_3_1(s);
                // Case 3-1-2 (e.g., values 2, 0, 1)
                else if (top_idx > mid_idx && mid_idx < bot_idx && top_idx > bot_idx)
                    handle_case_3_1_2(s);
                // Case 3-2-1 (e.g., values 2, 1, 0)
                else if (top_idx > mid_idx && mid_idx > bot_idx)
                    handle_case_3_2_1(s);
                // Case 1-2-3 (sorted) is handled by the initial is_sorted check.
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/sort_small_cases.c</code> (15/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">handle_case_1_3_2</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ordenar la <code class="nombre-pila">Pila A</code> cuando los índices de los 3 elementos están en el orden 1-3-2 (ej: valores 0, 2, 1).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <p class="text-sm">Ejecuta la secuencia: <code class="nombre-operacion">sa</code>, <code class="nombre-operacion">ra</code>.</p>
                                     <ol class="list-decimal list-inside space-y-1 pl-4 text-xs text-[var(--color-text-tertiary)]">
                                        <li>Inicial: A = [0, 2, 1]</li>
                                        <li><code class="nombre-operacion">sa</code>: A = [2, 0, 1]</li>
                                        <li><code class="nombre-operacion">ra</code>: A = [0, 1, 2] (Ordenado)</li>
                                     </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">do_sa</code>, <code class="nombre-funcion">do_ra</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    handle_case_1_3_2(t_stacks *s)
            {
                do_sa(s, 1); // Swap top two (A becomes 3-1-2)
                do_ra(s, 1); // Rotate A up (A becomes 1-2-3)
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">handle_case_2_1_3</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ordenar la <code class="nombre-pila">Pila A</code> cuando los índices de los 3 elementos están en el orden 2-1-3 (ej: valores 1, 0, 2).</p>
                                     <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <p class="text-sm">Ejecuta la secuencia: <code class="nombre-operacion">sa</code>.</p>
                                     <ol class="list-decimal list-inside space-y-1 pl-4 text-xs text-[var(--color-text-tertiary)]">
                                        <li>Inicial: A = [1, 0, 2]</li>
                                        <li><code class="nombre-operacion">sa</code>: A = [0, 1, 2] (Ordenado)</li>
                                     </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">do_sa</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    handle_case_2_1_3(t_stacks *s)
            {
                do_sa(s, 1); // Swap top two (A becomes 1-2-3)
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">handle_case_2_3_1</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ordenar la <code class="nombre-pila">Pila A</code> cuando los índices de los 3 elementos están en el orden 2-3-1 (ej: valores 1, 2, 0).</p>
                                     <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <p class="text-sm">Ejecuta la secuencia: <code class="nombre-operacion">rra</code>.</p>
                                     <ol class="list-decimal list-inside space-y-1 pl-4 text-xs text-[var(--color-text-tertiary)]">
                                        <li>Inicial: A = [1, 2, 0]</li>
                                        <li><code class="nombre-operacion">rra</code>: A = [0, 1, 2] (Ordenado)</li>
                                     </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">do_rra</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    handle_case_2_3_1(t_stacks *s)
            {
                do_rra(s, 1); // Reverse rotate A (A becomes 1-2-3)
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">handle_case_3_1_2</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ordenar la <code class="nombre-pila">Pila A</code> cuando los índices de los 3 elementos están en el orden 3-1-2 (ej: valores 2, 0, 1).</p>
                                     <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <p class="text-sm">Ejecuta la secuencia: <code class="nombre-operacion">ra</code>.</p>
                                     <ol class="list-decimal list-inside space-y-1 pl-4 text-xs text-[var(--color-text-tertiary)]">
                                        <li>Inicial: A = [2, 0, 1]</li>
                                        <li><code class="nombre-operacion">ra</code>: A = [0, 1, 2] (Ordenado)</li>
                                     </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">do_ra</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    handle_case_3_1_2(t_stacks *s)
            {
                do_ra(s, 1); // Rotate A up (A becomes 1-2-3)
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">handle_case_3_2_1</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ordenar la <code class="nombre-pila">Pila A</code> cuando los índices de los 3 elementos están en el orden 3-2-1 (ej: valores 2, 1, 0).</p>
                                     <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *s</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <p class="text-sm">Ejecuta la secuencia: <code class="nombre-operacion">sa</code>, <code class="nombre-operacion">rra</code>.</p>
                                     <ol class="list-decimal list-inside space-y-1 pl-4 text-xs text-[var(--color-text-tertiary)]">
                                        <li>Inicial: A = [2, 1, 0]</li>
                                        <li><code class="nombre-operacion">sa</code>: A = [1, 2, 0]</li>
                                        <li><code class="nombre-operacion">rra</code>: A = [0, 1, 2] (Ordenado)</li>
                                     </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">do_sa</code>, <code class="nombre-funcion">do_rra</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    handle_case_3_2_1(t_stacks *s)
            {
                do_sa(s, 1);  // Swap top two (A becomes 2-3-1)
                do_rra(s, 1); // Reverse rotate A (A becomes 1-2-3)
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/sort_cost.c</code> (16/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">calculate_cost_to_b</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Calcular y asignar los costes de rotación (<code class="nombre-campo">cost_a</code> y <code class="nombre-campo">cost_b</code>) para <strong>cada nodo</strong> en la <code class="nombre-pila">Pila A</code>. Estos costes representan el número mínimo de rotaciones (<code class="nombre-operacion">ra</code>/<code class="nombre-operacion">rra</code> y <code class="nombre-operacion">rb</code>/<code class="nombre-operacion">rrb</code>) necesarias para llevar el nodo de A a la cima de A y su nodo objetivo en B a la cima de B, respectivamente.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-struct">stacks</code> o alguna de las pilas A o B son <code class="nombre-constante">NULL</code>.</li>
                                        <li>Obtiene los tamaños actuales de A (<code class="nombre-tipo">size_a</code>) y B (<code class="nombre-tipo">size_b</code>).</li>
                                        <li>Itera sobre cada nodo (<code class="nombre-tipo">current_a</code>) en la <code class="nombre-pila">Pila A</code>.</li>
                                        <li>Para cada nodo <code class="nombre-tipo">current_a</code>:
                                            <ul>
                                                <li>Calcula <code class="nombre-campo">cost_a</code>: Si la posición actual (<code class="nombre-campo">current_a->pos</code>) está en la primera mitad de A, el coste es <code class="nombre-campo">pos</code> (positivo, para <code class="nombre-operacion">ra</code>). Si está en la segunda mitad, el coste es <code class="nombre-campo">pos - size_a</code> (negativo, para <code class="nombre-operacion">rra</code>).</li>
                                                <li>Calcula <code class="nombre-campo">cost_b</code>: Si la posición objetivo en B (<code class="nombre-campo">current_a->target_pos</code>) está en la primera mitad de B, el coste es <code class="nombre-campo">target_pos</code> (positivo, para <code class="nombre-operacion">rb</code>). Si está en la segunda mitad, el coste es <code class="nombre-campo">target_pos - size_b</code> (negativo, para <code class="nombre-operacion">rrb</code>).</li>
                                                <li>Asigna los costes calculados a los campos <code class="nombre-campo">current_a->cost_a</code> y <code class="nombre-campo">current_a->cost_b</code>.</li>
                                            </ul>
                                        </li>
                                        <li>Continúa hasta recorrer toda la <code class="nombre-pila">Pila A</code>.</li>
                                    </ol>
                                    <h5>Nota</h5>
                                    <p class="text-sm">Esta función asume que las posiciones (<code class="nombre-campo">pos</code>) y las posiciones objetivo (<code class="nombre-campo">target_pos</code>) ya han sido calculadas y actualizadas previamente (por <code class="nombre-funcion">update_positions</code> y <code class="nombre-funcion">assign_target_pos_b</code>).</p>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    calculate_cost_to_b(t_stacks *stacks)
            {
                t_stack_node    *current_a;
                int             size_a;
                int             size_b;
            
                if (!stacks || !stacks->a || !stacks->b)
                    return ; // Cannot calculate costs if stacks are missing
            
                current_a = stacks->a; // Start from the head of A
                size_a = stacks->size_a;
                size_b = stacks->size_b;
            
                // Loop through each node in stack A
                while (1)
                {
                    // Calculate cost_a: rotations needed to bring current_a to top of A
                    if (current_a->pos <= size_a / 2) // If in first half
                        current_a->cost_a = current_a->pos; // Cost is positive (ra)
                    else // If in second half
                        current_a->cost_a = current_a->pos - size_a; // Cost is negative (rra)
            
                    // Calculate cost_b: rotations needed to bring target_pos to top of B
                    if (current_a->target_pos <= size_b / 2) // If target is in first half
                        current_a->cost_b = current_a->target_pos; // Cost is positive (rb)
                    else // If target is in second half
                        current_a->cost_b = current_a->target_pos - size_b; // Cost is negative (rrb)
            
                    current_a = current_a->next; // Move to next node in A
                    if (current_a == stacks->a) // Stop if we've looped back to head
                        break ;
                }
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">calculate_cost_to_a</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Calcular el coste de rotación (<code class="nombre-campo">cost_a</code>) necesario para llevar la posición objetivo en A (<code class="nombre-campo">target_pos</code>) a la cima de A, específicamente para el nodo que está actualmente en la cima de la <code class="nombre-pila">Pila B</code>. También resetea <code class="nombre-campo">cost_b</code> a 0.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                     <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-struct">stacks</code> o alguna de las pilas A o B son <code class="nombre-constante">NULL</code>.</li>
                                        <li>Obtiene un puntero al nodo superior de B (<code class="nombre-tipo">top_b</code>) y el tamaño de A (<code class="nombre-tipo">size_a</code>).</li>
                                        <li>Si la posición objetivo del nodo <code class="nombre-tipo">top_b</code> es -1 (inválida), asigna <code class="nombre-constante">INT_MAX</code> a <code class="nombre-campo">cost_a</code> (para indicar que este movimiento no es viable o prioritario) y retorna.</li>
                                         <li>Calcula <code class="nombre-campo">cost_a</code> para <code class="nombre-tipo">top_b</code>: Si <code class="nombre-campo">target_pos</code> está en la primera mitad de A, el coste es <code class="nombre-campo">target_pos</code> (positivo, <code class="nombre-operacion">ra</code>). Si está en la segunda mitad, el coste es <code class="nombre-campo">target_pos - size_a</code> (negativo, <code class="nombre-operacion">rra</code>).</li>
                                         <li>Asigna 0 a <code class="nombre-campo">top_b->cost_b</code>, ya que el nodo ya está en la cima de B y no requiere rotaciones en B para ser empujado.</li>
                                    </ol>
                                     <h5>Nota</h5>
                                    <p class="text-sm">Esta función se usa típicamente dentro del bucle <code class="nombre-funcion">move_all_to_a</code>, justo antes de decidir cómo rotar A para recibir el elemento de B.</p>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    calculate_cost_to_a(t_stacks *stacks)
            {
                t_stack_node    *top_b;
                int             size_a;
            
                if (!stacks || !stacks->a || !stacks->b)
                    return ; // Cannot calculate costs if stacks are missing
            
                top_b = stacks->b; // Get the node currently at the top of B
                size_a = stacks->size_a;
            
                // If the target position in A is invalid (should not happen in normal flow)
                if (top_b->target_pos == -1)
                {
                    top_b->cost_a = INT_MAX; // Assign a high cost to avoid processing
                    return ;
                }
            
                // Calculate cost_a: rotations needed to bring target_pos to top of A
                if (top_b->target_pos <= size_a / 2) // If target is in first half
                    top_b->cost_a = top_b->target_pos; // Cost is positive (ra)
                else // If target is in second half
                    top_b->cost_a = top_b->target_pos - size_a; // Cost is negative (rra)
            
                // Cost B is always 0 because the node is already at the top of B
                top_b->cost_b = 0;
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">abs_val</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Calcular el valor absoluto de un número entero.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int n</code>: El número entero de entrada.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int</code>: El valor absoluto de <code class="nombre-tipo">n</code>.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Si <code class="nombre-tipo">n</code> es menor que 0, retorna <code class="nombre-tipo">-n</code>.</li>
                                        <li>De lo contrario (si <code class="nombre-tipo">n</code> es 0 o positivo), retorna <code class="nombre-tipo">n</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int abs_val(int n)
            {
                if (n < 0)
                    return (-n); // Return the negation if n is negative
                return (n);      // Otherwise, return n itself
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/operations/ops_push.c</code> (17/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">detach_top_node</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Extraer (desvincular) el nodo superior de una pila fuente (<code class="nombre-tipo">src</code>) y devolverlo como un nodo aislado (lista circular de un solo elemento), actualizando correctamente la pila fuente.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-tipo">t_stack_node **src</code>: Doble puntero a la cabeza de la pila fuente. Necesario para modificar la cabeza de la pila fuente.</li>
                                    </ul>
                                     <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-tipo">t_stack_node *</code>: Puntero al nodo que fue extraído (ahora apunta a sí mismo en <code class="nombre-campo">prev</code>/<code class="nombre-campo">next</code>).</li>
                                         <li><code class="nombre-constante">NULL</code>: Si la pila fuente es <code class="nombre-constante">NULL</code> o está vacía.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-tipo">src</code> o <code class="nombre-tipo">*src</code> son <code class="nombre-constante">NULL</code>.</li>
                                        <li>Guarda el nodo superior actual en <code class="nombre-tipo">node_to_push</code>.</li>
                                        <li>Caso especial: Si la pila fuente solo tiene un nodo (<code class="nombre-campo">(*src)->next == *src</code>), establece la cabeza de la pila fuente a <code class="nombre-constante">NULL</code>. El nodo extraído ya apunta a sí mismo.</li>
                                        <li>Caso general (más de un nodo):
                                            <ul>
                                                <li>Obtiene punteros a la cola (<code class="nombre-tipo">src_tail</code>) y al segundo nodo (<code class="nombre-tipo">src_second</code>) de la pila fuente.</li>
                                                <li>Actualiza los punteros de la cola y del segundo nodo para que se enlacen entre sí, eliminando el nodo superior original de la lista circular.</li>
                                                <li>Actualiza la cabeza de la pila fuente (<code class="nombre-tipo">*src</code>) para que apunte al segundo nodo.</li>
                                                <li>Reestablece los punteros <code class="nombre-campo">prev</code> y <code class="nombre-campo">next</code> del nodo extraído (<code class="nombre-tipo">node_to_push</code>) para que apunten a sí mismo, aislándolo.</li>
                                            </ul>
                                        </li>
                                         <li>Retorna el puntero al nodo extraído (<code class="nombre-tipo">node_to_push</code>).</li>
                                    </ol>
                                     <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static t_stack_node *detach_top_node(t_stack_node **src)
            {
                t_stack_node    *node_to_push;
                t_stack_node    *src_tail;
                t_stack_node    *src_second;
            
                if (!src || !*src) // Check if source stack pointer or stack itself is NULL
                    return (NULL);
            
                node_to_push = *src; // Node to be removed is the current head
            
                // Case 1: Only one node in the source stack
                if ((*src)->next == *src)
                {
                    *src = NULL; // Source stack becomes empty
                }
                // Case 2: More than one node in the source stack
                else
                {
                    src_tail = (*src)->prev;   // Get the tail of the source stack
                    src_second = (*src)->next; // Get the second node (new head)
            
                    // Link the tail and the second node together, bypassing the head
                    src_tail->next = src_second;
                    src_second->prev = src_tail;
            
                    // Update the source stack head to point to the second node
                    *src = src_second;
            
                    // Isolate the detached node by making it point to itself
                    node_to_push->prev = node_to_push;
                    node_to_push->next = node_to_push;
                }
                // Return the detached node
                return (node_to_push);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">push</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Realizar la operación de "push" genérica: mover el nodo superior de una pila fuente (<code class="nombre-tipo">src</code>) a la cima de una pila destino (<code class="nombre-tipo">dest</code>).</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-tipo">t_stack_node **dest</code>: Doble puntero a la cabeza de la pila destino.</li>
                                         <li><code class="nombre-tipo">t_stack_node **src</code>: Doble puntero a la cabeza de la pila fuente.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Llama a <code class="nombre-funcion">detach_top_node</code> para extraer el nodo superior de la pila <code class="nombre-tipo">src</code>.</li>
                                        <li>Si <code class="nombre-funcion">detach_top_node</code> devuelve <code class="nombre-constante">NULL</code> (porque <code class="nombre-tipo">src</code> estaba vacía), retorna.</li>
                                        <li>Caso especial: Si la pila destino (<code class="nombre-tipo">*dest</code>) está vacía, el nodo extraído se convierte en la nueva cabeza de <code class="nombre-tipo">dest</code>.</li>
                                        <li>Caso general (destino no vacío):
                                            <ul>
                                                <li>Obtiene un puntero a la cola actual de la pila destino (<code class="nombre-tipo">dest_tail</code>).</li>
                                                <li>Actualiza los punteros para insertar <code class="nombre-tipo">node_to_push</code> al principio de la lista circular de destino: enlaza la cola de destino con el nuevo nodo, el nuevo nodo con la antigua cabeza de destino, y la antigua cabeza de destino con el nuevo nodo.</li>
                                                 <li>Actualiza la cabeza de la pila destino (<code class="nombre-tipo">*dest</code>) para que apunte al nodo recién insertado.</li>
                                            </ul>
                                        </li>
                                    </ol>
                                     <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">detach_top_node</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void push(t_stack_node **dest, t_stack_node **src)
            {
                t_stack_node    *node_to_push;
                t_stack_node    *dest_tail;
            
                // 1. Remove the top node from the source stack
                node_to_push = detach_top_node(src);
                if (!node_to_push) // If source was empty, nothing to push
                    return ;
            
                // 2. Add the detached node to the destination stack
                // Case A: Destination stack is currently empty
                if (*dest == NULL)
                {
                    *dest = node_to_push; // The pushed node becomes the only node
                    // node_to_push already points to itself (prev/next)
                }
                // Case B: Destination stack is not empty
                else
                {
                    dest_tail = (*dest)->prev; // Get the current tail of destination
            
                    // Insert node_to_push at the beginning (before *dest)
                    dest_tail->next = node_to_push; // Link tail to new node
                    node_to_push->prev = dest_tail; // Link new node back to tail
                    node_to_push->next = *dest;     // Link new node to old head
                    (*dest)->prev = node_to_push; // Link old head back to new node
            
                    // Update the destination head to point to the newly pushed node
                    *dest = node_to_push;
                }
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_pa</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Push A": mover el elemento superior de la <code class="nombre-pila">Pila B</code> a la cima de la <code class="nombre-pila">Pila A</code>. Actualiza los tamaños de las pilas y opcionalmente imprime "pa".</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación ("pa\n") en la salida estándar.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila B</code> tiene al menos un elemento (<code class="nombre-campo">stacks->size_b < 1</code>). Si no, retorna.</li>
                                        <li>Llama a la función <code class="nombre-funcion">push</code>, pasando <code class="nombre-campo">stacks->a</code> como destino y <code class="nombre-campo">stacks->b</code> como fuente.</li>
                                        <li>Incrementa el tamaño de A (<code class="nombre-campo">stacks->size_a++</code>).</li>
                                        <li>Decrementa el tamaño de B (<code class="nombre-campo">stacks->size_b--</code>).</li>
                                        <li>Si el flag <code class="nombre-tipo">print</code> es verdadero (1), imprime "pa\n" en <code class="nombre-constante">STDOUT_FD</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">push</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_pa(t_stacks *stacks, int print)
            {
                // Cannot push from B if B is empty
                if (!stacks || stacks->size_b < 1)
                    return ;
            
                // Perform the push operation (A is destination, B is source)
                push(&(stacks->a), &(stacks->b));
            
                // Update stack sizes
                stacks->size_a++;
                stacks->size_b--;
            
                // Print the operation if requested
                if (print)
                    ft_putstr_fd("pa\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                             <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_pb</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Push B": mover el elemento superior de la <code class="nombre-pila">Pila A</code> a la cima de la <code class="nombre-pila">Pila B</code>. Actualiza los tamaños de las pilas y opcionalmente imprime "pb".</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación ("pb\n") en la salida estándar.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                         <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila A</code> tiene al menos un elemento (<code class="nombre-campo">stacks->size_a < 1</code>). Si no, retorna.</li>
                                        <li>Llama a la función <code class="nombre-funcion">push</code>, pasando <code class="nombre-campo">stacks->b</code> como destino y <code class="nombre-campo">stacks->a</code> como fuente.</li>
                                        <li>Incrementa el tamaño de B (<code class="nombre-campo">stacks->size_b++</code>).</li>
                                        <li>Decrementa el tamaño de A (<code class="nombre-campo">stacks->size_a--</code>).</li>
                                        <li>Si el flag <code class="nombre-tipo">print</code> es verdadero (1), imprime "pb\n" en <code class="nombre-constante">STDOUT_FD</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">push</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_pb(t_stacks *stacks, int print)
            {
                // Cannot push from A if A is empty
                if (!stacks || stacks->size_a < 1)
                    return ;
            
                // Perform the push operation (B is destination, A is source)
                push(&(stacks->b), &(stacks->a));
            
                // Update stack sizes
                stacks->size_b++;
                stacks->size_a--;
            
                // Print the operation if requested
                if (print)
                    ft_putstr_fd("pb\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/operations/ops_reverse_rotate.c</code> (18/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">reverse_rotate</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Realizar la operación de rotación inversa en una única pila (lista doblemente enlazada circular). El último elemento se convierte en el nuevo primer elemento.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node **stack</code>: Doble puntero a la cabeza de la pila a rotar. Necesario para modificar la cabeza de la pila.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si el doble puntero <code class="nombre-tipo">stack</code> es <code class="nombre-constante">NULL</code>, si la pila está vacía (<code class="nombre-tipo">*stack</code> es <code class="nombre-constante">NULL</code>), o si la pila tiene un solo elemento (<code class="nombre-campo">(*stack)->next == *stack</code>). En cualquiera de estos casos, la rotación no tiene efecto o no es posible, así que retorna.</li>
                                        <li>Actualiza el puntero de la cabeza de la pila (<code class="nombre-tipo">*stack</code>) para que apunte al nodo que <em>antes</em> era el último (accedido mediante <code class="nombre-campo">(*stack)->prev</code>). Este nodo se convierte en la nueva cabeza. Gracias a la estructura circular, esto es todo lo necesario para efectuar la rotación inversa.</li>
                                    </ol>
                                     <h5>Nota</h5>
                                     <p class="text-sm">Esta operación es O(1) gracias a la lista doblemente enlazada circular.</p>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void reverse_rotate(t_stack_node **stack)
            {
                // No rotation needed for NULL, empty, or single-node stacks
                if (!stack || !*stack || (*stack)->next == *stack)
                    return ;
            
                // The new head becomes the current tail (previous node of the current head)
                *stack = (*stack)->prev;
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_rra</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Reverse Rotate A" (<code class="nombre-operacion">rra</code>): rotar inversamente la <code class="nombre-pila">Pila A</code>. Opcionalmente imprime "rra".</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila A</code> tiene al menos 2 elementos (<code class="nombre-campo">stacks->size_a < 2</code>). Si no, la operación no tiene sentido y retorna.</li>
                                        <li>Llama a la función <code class="nombre-funcion">reverse_rotate</code> pasando la dirección de la cabeza de la <code class="nombre-pila">Pila A</code> (<code class="nombre-campo">&(stacks->a)</code>).</li>
                                        <li>Si el flag <code class="nombre-tipo">print</code> es verdadero, imprime "rra\n".</li>
                                     </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">reverse_rotate</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_rra(t_stacks *stacks, int print)
            {
                // Cannot reverse rotate A if it has less than 2 elements
                if (!stacks || stacks->size_a < 2)
                    return ;
            
                // Perform the reverse rotate operation on stack A
                reverse_rotate(&(stacks->a));
            
                // Print the operation if requested
                if (print)
                    ft_putstr_fd("rra\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_rrb</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Reverse Rotate B" (<code class="nombre-operacion">rrb</code>): rotar inversamente la <code class="nombre-pila">Pila B</code>. Opcionalmente imprime "rrb".</p>
                                     <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila B</code> tiene al menos 2 elementos (<code class="nombre-campo">stacks->size_b < 2</code>). Si no, retorna.</li>
                                        <li>Llama a la función <code class="nombre-funcion">reverse_rotate</code> pasando la dirección de la cabeza de la <code class="nombre-pila">Pila B</code> (<code class="nombre-campo">&(stacks->b)</code>).</li>
                                        <li>Si el flag <code class="nombre-tipo">print</code> es verdadero, imprime "rrb\n".</li>
                                     </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">reverse_rotate</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_rrb(t_stacks *stacks, int print)
            {
                // Cannot reverse rotate B if it has less than 2 elements
                if (!stacks || stacks->size_b < 2)
                    return ;
            
                // Perform the reverse rotate operation on stack B
                reverse_rotate(&(stacks->b));
            
                // Print the operation if requested
                if (print)
                    ft_putstr_fd("rrb\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_rrr</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Reverse Rotate Both" (<code class="nombre-operacion">rrr</code>): rotar inversamente ambas pilas, A y B, simultáneamente. Opcionalmente imprime "rrr" si al menos una rotación se realizó.</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Inicializa flags <code class="nombre-tipo">rotated_a</code> y <code class="nombre-tipo">rotated_b</code> a 0.</li>
                                        <li>Si <code class="nombre-struct">stacks</code> es válido y la <code class="nombre-pila">Pila A</code> tiene 2 o más elementos, llama a <code class="nombre-funcion">reverse_rotate</code> para A y pone <code class="nombre-tipo">rotated_a</code> a 1.</li>
                                         <li>Si <code class="nombre-struct">stacks</code> es válido y la <code class="nombre-pila">Pila B</code> tiene 2 o más elementos, llama a <code class="nombre-funcion">reverse_rotate</code> para B y pone <code class="nombre-tipo">rotated_b</code> a 1.</li>
                                        <li>Si el flag <code class="nombre-tipo">print</code> es verdadero Y al menos una de las rotaciones se realizó (<code class="nombre-tipo">rotated_a || rotated_b</code>), imprime "rrr\n".</li>
                                     </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">reverse_rotate</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_rrr(t_stacks *stacks, int print)
            {
                int rotated_a;
                int rotated_b;
            
                rotated_a = 0;
                rotated_b = 0;
            
                // Attempt to reverse rotate A if possible
                if (stacks && stacks->size_a >= 2)
                {
                    reverse_rotate(&(stacks->a));
                    rotated_a = 1; // Mark that A was rotated
                }
                // Attempt to reverse rotate B if possible
                if (stacks && stacks->size_b >= 2)
                {
                    reverse_rotate(&(stacks->b));
                    rotated_b = 1; // Mark that B was rotated
                }
            
                // Print "rrr" only if printing is enabled AND at least one stack was rotated
                if (print && (rotated_a || rotated_b))
                    ft_putstr_fd("rrr\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/operations/ops_rotate.c</code> (19/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">rotate</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Realizar la operación de rotación estándar en una única pila (lista doblemente enlazada circular). El primer elemento (cabeza) se mueve al final de la lista.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node **stack</code>: Doble puntero a la cabeza de la pila a rotar. Necesario para modificar la cabeza de la pila.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                         <li>Comprueba si el doble puntero <code class="nombre-tipo">stack</code> es <code class="nombre-constante">NULL</code>, si la pila está vacía (<code class="nombre-tipo">*stack</code> es <code class="nombre-constante">NULL</code>), o si la pila tiene un solo elemento (<code class="nombre-campo">(*stack)->next == *stack</code>). En estos casos, la rotación no tiene efecto y retorna.</li>
                                         <li>Actualiza el puntero de la cabeza de la pila (<code class="nombre-tipo">*stack</code>) para que apunte al nodo que <em>antes</em> era el segundo (<code class="nombre-campo">(*stack)->next</code>). Este nodo se convierte en la nueva cabeza. La estructura circular maneja automáticamente el movimiento del antiguo primer nodo al final.</li>
                                    </ol>
                                    <h5>Nota</h5>
                                    <p class="text-sm">Esta operación es O(1) gracias a la lista doblemente enlazada circular.</p>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void rotate(t_stack_node **stack)
            {
                // No rotation needed for NULL, empty, or single-node stacks
                if (!stack || !*stack || (*stack)->next == *stack)
                    return ;
            
                // The new head becomes the current second node (next node of the current head)
                *stack = (*stack)->next;
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_ra</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Rotate A" (<code class="nombre-operacion">ra</code>): rotar la <code class="nombre-pila">Pila A</code> (el primer elemento va al final). Opcionalmente imprime "ra".</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila A</code> tiene al menos 2 elementos (<code class="nombre-campo">stacks->size_a < 2</code>). Si no, retorna.</li>
                                        <li>Llama a la función <code class="nombre-funcion">rotate</code> pasando la dirección de la cabeza de la <code class="nombre-pila">Pila A</code> (<code class="nombre-campo">&(stacks->a)</code>).</li>
                                        <li>Si el flag <code class="nombre-tipo">print</code> es verdadero, imprime "ra\n".</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">rotate</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_ra(t_stacks *stacks, int print)
            {
                // Cannot rotate A if it has less than 2 elements
                if (!stacks || stacks->size_a < 2)
                    return ;
            
                // Perform the rotate operation on stack A
                rotate(&(stacks->a));
            
                // Print the operation if requested
                if (print)
                    ft_putstr_fd("ra\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_rb</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Rotate B" (<code class="nombre-operacion">rb</code>): rotar la <code class="nombre-pila">Pila B</code> (el primer elemento va al final). Opcionalmente imprime "rb".</p>
                                     <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                         <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila B</code> tiene al menos 2 elementos (<code class="nombre-campo">stacks->size_b < 2</code>). Si no, retorna.</li>
                                        <li>Llama a la función <code class="nombre-funcion">rotate</code> pasando la dirección de la cabeza de la <code class="nombre-pila">Pila B</code> (<code class="nombre-campo">&(stacks->b)</code>).</li>
                                        <li>Si el flag <code class="nombre-tipo">print</code> es verdadero, imprime "rb\n".</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">rotate</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_rb(t_stacks *stacks, int print)
            {
                // Cannot rotate B if it has less than 2 elements
                if (!stacks || stacks->size_b < 2)
                    return ;
            
                // Perform the rotate operation on stack B
                rotate(&(stacks->b));
            
                // Print the operation if requested
                if (print)
                    ft_putstr_fd("rb\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_rr</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Rotate Both" (<code class="nombre-operacion">rr</code>): rotar ambas pilas, A y B, simultáneamente. Opcionalmente imprime "rr" si al menos una rotación se realizó.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                         <li>Inicializa flags <code class="nombre-tipo">rotated_a</code> y <code class="nombre-tipo">rotated_b</code> a 0.</li>
                                        <li>Si <code class="nombre-struct">stacks</code> es válido y la <code class="nombre-pila">Pila A</code> tiene 2 o más elementos, llama a <code class="nombre-funcion">rotate</code> para A y pone <code class="nombre-tipo">rotated_a</code> a 1.</li>
                                         <li>Si <code class="nombre-struct">stacks</code> es válido y la <code class="nombre-pila">Pila B</code> tiene 2 o más elementos, llama a <code class="nombre-funcion">rotate</code> para B y pone <code class="nombre-tipo">rotated_b</code> a 1.</li>
                                        <li>Si el flag <code class="nombre-tipo">print</code> es verdadero Y al menos una de las rotaciones se realizó (<code class="nombre-tipo">rotated_a || rotated_b</code>), imprime "rr\n".</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">rotate</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_rr(t_stacks *stacks, int print)
            {
                int rotated_a;
                int rotated_b;
            
                rotated_a = 0;
                rotated_b = 0;
            
                // Attempt to rotate A if possible
                if (stacks && stacks->size_a >= 2)
                {
                    rotate(&(stacks->a));
                    rotated_a = 1; // Mark that A was rotated
                }
                // Attempt to rotate B if possible
                if (stacks && stacks->size_b >= 2)
                {
                    rotate(&(stacks->b));
                    rotated_b = 1; // Mark that B was rotated
                }
            
                // Print "rr" only if printing is enabled AND at least one stack was rotated
                if (print && (rotated_a || rotated_b))
                    ft_putstr_fd("rr\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">mandatory/srcs/operations/ops_swap.c</code> (20/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">swap</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Intercambiar las posiciones de los dos primeros nodos (los que están en la cima) de una pila (lista doblemente enlazada circular).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-tipo">t_stack_node **stack</code>: Doble puntero a la cabeza de la pila donde se realizará el intercambio. Necesario para modificar la cabeza.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                         <li>Comprueba si el doble puntero <code class="nombre-tipo">stack</code> es <code class="nombre-constante">NULL</code>, si la pila está vacía, o si tiene un solo nodo. En estos casos, el swap no es posible o no tiene efecto, y retorna.</li>
                                         <li>Obtiene punteros a los nodos clave involucrados: el primero (<code class="nombre-tipo">first = *stack</code>), el segundo (<code class="nombre-tipo">second = first->next</code>), el tercero (<code class="nombre-tipo">third = second->next</code>, necesario para reconectar después del segundo) y el último (<code class="nombre-tipo">last = first->prev</code>, la cola de la lista).</li>
                                         <li>Reorganiza cuidadosamente los punteros <code class="nombre-campo">next</code> y <code class="nombre-campo">prev</code> de estos cuatro nodos para efectuar el intercambio:
                                             <ul>
                                                 <li>El <code class="nombre-campo">next</code> del último ahora apunta al segundo.</li>
                                                 <li>El <code class="nombre-campo">prev</code> del segundo ahora apunta al último.</li>
                                                 <li>El <code class="nombre-campo">next</code> del segundo ahora apunta al primero.</li>
                                                 <li>El <code class="nombre-campo">prev</code> del primero ahora apunta al segundo.</li>
                                                 <li>El <code class="nombre-campo">next</code> del primero ahora apunta al tercero.</li>
                                                 <li>El <code class="nombre-campo">prev</code> del tercero ahora apunta al primero.</li>
                                             </ul>
                                         </li>
                                        <li>Actualiza la cabeza de la pila (<code class="nombre-tipo">*stack</code>) para que apunte al nodo que originalmente era el segundo, completando el swap.</li>
                                    </ol>
                                     <h5>Nota</h5>
                                     <p class="text-sm">Esta operación es O(1).</p>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void swap(t_stack_node **stack)
            {
                t_stack_node    *first;
                t_stack_node    *second;
                t_stack_node    *third;
                t_stack_node    *last;
            
                // No swap needed for NULL, empty, or single-node stacks
                if (!stack || !*stack || (*stack)->next == *stack)
                    return ;
            
                // Get pointers to the key nodes involved in the swap
                first = *stack;         // Current head (node 1)
                second = first->next;   // Node 2
                third = second->next;   // Node 3 (needed to link after node 1)
                last = first->prev;     // The tail node
            
                // Rearrange pointers to swap 'first' and 'second'
                last->next = second;    // Tail points to second
                second->prev = last;    // Second points back to tail
                second->next = first;   // Second points to first
                first->prev = second;   // First points back to second
                first->next = third;    // First points to third
                third->prev = first;    // Third points back to first
            
                // Update the stack head to point to the node that was originally second
                *stack = second;
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_sa</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Swap A" (<code class="nombre-operacion">sa</code>): intercambiar los dos primeros elementos de la <code class="nombre-pila">Pila A</code>. Opcionalmente imprime "sa".</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                     <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila A</code> tiene al menos 2 elementos (<code class="nombre-campo">stacks->size_a < 2</code>). Si no, retorna.</li>
                                        <li>Llama a la función <code class="nombre-funcion">swap</code> pasando la dirección de la cabeza de la <code class="nombre-pila">Pila A</code> (<code class="nombre-campo">&(stacks->a)</code>).</li>
                                         <li>Si el flag <code class="nombre-tipo">print</code> es verdadero, imprime "sa\n".</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">swap</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_sa(t_stacks *stacks, int print)
            {
                // Cannot swap A if it has less than 2 elements
                if (!stacks || stacks->size_a < 2)
                    return ;
            
                // Perform the swap operation on stack A
                swap(&(stacks->a));
            
                // Print the operation if requested
                if (print)
                    ft_putstr_fd("sa\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_sb</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Swap B" (<code class="nombre-operacion">sb</code>): intercambiar los dos primeros elementos de la <code class="nombre-pila">Pila B</code>. Opcionalmente imprime "sb".</p>
                                     <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                         <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila B</code> tiene al menos 2 elementos (<code class="nombre-campo">stacks->size_b < 2</code>). Si no, retorna.</li>
                                        <li>Llama a la función <code class="nombre-funcion">swap</code> pasando la dirección de la cabeza de la <code class="nombre-pila">Pila B</code> (<code class="nombre-campo">&(stacks->b)</code>).</li>
                                         <li>Si el flag <code class="nombre-tipo">print</code> es verdadero, imprime "sb\n".</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">swap</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_sb(t_stacks *stacks, int print)
            {
                // Cannot swap B if it has less than 2 elements
                if (!stacks || stacks->size_b < 2)
                    return ;
            
                // Perform the swap operation on stack B
                swap(&(stacks->b));
            
                // Print the operation if requested
                if (print)
                    ft_putstr_fd("sb\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">do_ss</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Ejecutar la operación "Swap Both" (<code class="nombre-operacion">ss</code>): intercambiar los dos primeros elementos de ambas pilas, A y B, simultáneamente. Opcionalmente imprime "ss" si al menos un intercambio se realizó.</p>
                                     <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                        <li><code class="nombre-tipo">int print</code>: Flag para indicar si se debe imprimir la operación.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Inicializa flags <code class="nombre-tipo">swapped_a</code> y <code class="nombre-tipo">swapped_b</code> a 0.</li>
                                        <li>Si <code class="nombre-struct">stacks</code> es válido y la <code class="nombre-pila">Pila A</code> tiene 2 o más elementos, llama a <code class="nombre-funcion">swap</code> para A y pone <code class="nombre-tipo">swapped_a</code> a 1.</li>
                                         <li>Si <code class="nombre-struct">stacks</code> es válido y la <code class="nombre-pila">Pila B</code> tiene 2 o más elementos, llama a <code class="nombre-funcion">swap</code> para B y pone <code class="nombre-tipo">swapped_b</code> a 1.</li>
                                        <li>Si el flag <code class="nombre-tipo">print</code> es verdadero Y al menos uno de los intercambios se realizó (<code class="nombre-tipo">swapped_a || swapped_b</code>), imprime "ss\n".</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">swap</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    do_ss(t_stacks *stacks, int print)
            {
                int swapped_a;
                int swapped_b;
            
                swapped_a = 0;
                swapped_b = 0;
            
                // Attempt to swap A if possible
                if (stacks && stacks->size_a >= 2)
                {
                    swap(&(stacks->a));
                    swapped_a = 1; // Mark that A was swapped
                }
                // Attempt to swap B if possible
                if (stacks && stacks->size_b >= 2)
                {
                    swap(&(stacks->b));
                    swapped_b = 1; // Mark that B was swapped
                }
            
                // Print "ss" only if printing is enabled AND at least one stack was swapped
                if (print && (swapped_a || swapped_b))
                    ft_putstr_fd("ss\n", STDOUT_FD);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">bonus/srcs/checker_main.c</code> (21/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">print_result</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Imprimir el resultado final ("OK" o "KO") basado en el estado de las pilas después de ejecutar las instrucciones leídas.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si la <code class="nombre-pila">Pila A</code> está ordenada (<code class="nombre-funcion">is_sorted(stacks->a)</code>) Y si la <code class="nombre-pila">Pila B</code> está vacía (<code class="nombre-campo">stacks->size_b == 0</code>).</li>
                                        <li>Si ambas condiciones son verdaderas, imprime "OK\n" en la salida estándar.</li>
                                        <li>De lo contrario, imprime "KO\n" en la salida estándar.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">is_sorted</code>, <code class="nombre-funcion">ft_putstr_fd</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void print_result(t_stacks *stacks)
            {
                // Check if stack A is sorted AND stack B is empty
                if (is_sorted(stacks->a) && stacks->size_b == 0)
                    ft_putstr_fd("OK\n", STDOUT_FD); // Print OK if conditions met
                else
                    ft_putstr_fd("KO\n", STDOUT_FD); // Print KO otherwise
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">init_and_parse</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Inicializar la estructura <code class="nombre-struct">t_stacks</code> y parsear/validar los argumentos de la línea de comandos (la lista inicial de números).</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int argc</code>: Número de argumentos.</li>
                                        <li><code class="nombre-tipo">char **argv</code>: Array de argumentos.</li>
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal a inicializar y llenar.</li>
                                    </ul>
                                     <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-constante">1</code>: Si la inicialización y el parsing son exitosos y se cargaron números en la Pila A.</li>
                                         <li><code class="nombre-constante">0</code>: Si no hay argumentos (<code class="nombre-tipo">argc < 2</code>), si <code class="nombre-funcion">parse_arguments</code> falla, o si el parsing fue exitoso pero no se cargó ningún número (ej. <code>./checker ""</code>).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Inicializa todos los campos de <code class="nombre-struct">stacks</code> a <code class="nombre-constante">NULL</code> o 0.</li>
                                        <li>Si <code class="nombre-tipo">argc < 2</code>, retorna 0 (no hay números para verificar).</li>
                                        <li>Llama a <code class="nombre-funcion">parse_arguments</code> (la misma función usada en `push_swap`) para validar y cargar los números en la <code class="nombre-pila">Pila A</code>.</li>
                                        <li>Si <code class="nombre-funcion">parse_arguments</code> retorna 0 (error), esta función también retorna 0.</li>
                                        <li>Comprueba si, después de un parsing exitoso, la <code class="nombre-pila">Pila A</code> quedó vacía (<code class="nombre-campo">stacks->size_a == 0</code>) pero se proporcionaron argumentos (<code class="nombre-tipo">argc >= 2</code>). Esto indica una entrada válida pero sin números (ej. <code>./checker ""</code> o <code>./checker " "</code>). En este caso, libera la memoria y retorna 0 porque no hay nada que verificar.</li>
                                         <li>Si todo fue bien y hay números en A, retorna 1.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">parse_arguments</code>, <code class="nombre-funcion">free_stacks</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static int  init_and_parse(int argc, char **argv, t_stacks *stacks)
            {
                // Initialize the stacks structure
                stacks->a = NULL;
                stacks->b = NULL;
                stacks->size_a = 0;
                stacks->size_b = 0;
                stacks->split_args = NULL;
            
                // Check if there are enough arguments (program name + at least one number/string)
                if (argc < 2)
                    return (0); // Not enough arguments, nothing to check
            
                // Parse the command-line arguments into stack A
                if (!parse_arguments(argc, argv, stacks))
                {
                    // parse_arguments calls exit_error on failure, but we handle return here too
                    return (0); // Parsing failed
                }
            
                // Handle cases where parsing succeeded but resulted in an empty stack
                // (e.g., ./checker "" or ./checker "   ")
                if (stacks->size_a == 0 && argc >= 2)
                {
                    free_stacks(stacks); // Free memory if split_args was allocated
                    return (0); // Valid input, but nothing to check
                }
            
                // Initialization and parsing successful
                return (1);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">main</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Punto de entrada principal del programa `checker`. Orquesta la inicialización, el parsing de argumentos, la lectura y ejecución de instrucciones, la impresión del resultado y la limpieza.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-tipo">int argc</code>: Número de argumentos.</li>
                                        <li><code class="nombre-tipo">char **argv</code>: Array de argumentos.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-constante">EXIT_SUCCESS</code> (0): Si el programa se ejecuta correctamente y determina un resultado ("OK" o "KO"), o si no se proporcionan argumentos iniciales.</li>
                                        <li><code class="nombre-constante">EXIT_FAILURE</code> (1): Si ocurre un error durante el parsing de argumentos iniciales o durante la lectura/ejecución de instrucciones.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Llama a <code class="nombre-funcion">init_and_parse</code> para inicializar <code class="nombre-struct">stacks</code> y procesar los argumentos <code class="nombre-tipo">argc</code>/<code class="nombre-tipo">argv</code>.</li>
                                        <li>Si <code class="nombre-funcion">init_and_parse</code> falla (retorna 0):
                                            <ul>
                                                <li>Si falló porque había argumentos pero eran inválidos o vacíos (<code class="nombre-tipo">argc >= 2</code>), retorna <code class="nombre-constante">EXIT_FAILURE</code> (ya que <code class="nombre-funcion">parse_arguments</code> habrá impreso "Error").</li>
                                                 <li>Si falló porque no había argumentos (<code class="nombre-tipo">argc < 2</code>), retorna <code class="nombre-constante">EXIT_SUCCESS</code>.</li>
                                            </ul>
                                        </li>
                                         <li>Si la inicialización y el parsing fueron exitosos, llama a <code class="nombre-funcion">read_and_execute_instructions</code> (función definida en otro archivo, probablemente `checker_utils.c`) para leer las operaciones desde la entrada estándar y aplicarlas a las pilas.</li>
                                         <li>Si <code class="nombre-funcion">read_and_execute_instructions</code> retorna 0 (indicando una instrucción inválida), libera memoria con <code class="nombre-funcion">free_stacks</code>, imprime "Error" y retorna <code class="nombre-constante">EXIT_FAILURE</code>.</li>
                                         <li>Si las instrucciones se leyeron y ejecutaron correctamente, llama a <code class="nombre-funcion">print_result</code> para imprimir "OK" o "KO".</li>
                                         <li>Llama a <code class="nombre-funcion">free_stacks</code> para liberar toda la memoria.</li>
                                         <li>Retorna <code class="nombre-constante">EXIT_SUCCESS</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">init_and_parse</code>, <code class="nombre-funcion">read_and_execute_instructions</code> (asumida), <code class="nombre-funcion">free_stacks</code>, <code class="nombre-funcion">ft_putstr_fd</code>, <code class="nombre-funcion">print_result</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int main(int argc, char **argv)
            {
                t_stacks    stacks;
            
                // 1. Initialize structure and parse initial stack numbers from arguments
                if (!init_and_parse(argc, argv, &stacks))
                {
                    // Handle different failure reasons from init_and_parse
                    if (argc >= 2) // If there were args, failure means invalid input
                         return (EXIT_FAILURE); // Error message printed by parse_arguments
                    else // If argc < 2, it's not an error, just nothing to do
                         return (EXIT_SUCCESS);
                }
            
                // 2. Read instructions from standard input and execute them
                if (!read_and_execute_instructions(&stacks)) // Assumes this func exists
                {
                    // If an invalid instruction was read
                    free_stacks(&stacks); // Clean up allocated memory
                    ft_putstr_fd(ERROR_MSG, STDERR_FD); // Print "Error"
                    return (EXIT_FAILURE);
                }
            
                // 3. Print the final result (OK or KO)
                print_result(&stacks);
            
                // 4. Clean up allocated memory
                free_stacks(&stacks);
            
                // 5. Exit successfully
                return (EXIT_SUCCESS);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">bonus/srcs/checker_utils.c</code> (22/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">execute_instruction</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Comparar una cadena de instrucción leída con las operaciones válidas de push_swap y ejecutar la operación correspondiente en las pilas si se encuentra una coincidencia. Utiliza las versiones `_bonus` de las funciones de operaciones, que no imprimen la operación realizada.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal que contiene las pilas.</li>
                                        <li><code class="nombre-tipo">const char *instruction</code>: La cadena leída desde la entrada estándar (ej. "sa\n", "pb\n").</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-constante">1</code>: Si la instrucción es válida y se ejecutó la operación correspondiente.</li>
                                         <li><code class="nombre-constante">0</code>: Si la cadena <code class="nombre-tipo">instruction</code> no coincide con ninguna operación válida.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-1 pl-4 text-sm">
                                        <li>Utiliza una serie de <code class="concepto-clave">if-else if</code> para comparar la cadena <code class="nombre-tipo">instruction</code> con cada una de las operaciones válidas ("sa\n", "sb\n", "ss\n", "pa\n", "pb\n", "ra\n", "rb\n", "rr\n", "rra\n", "rrb\n", "rrr\n") usando <code class="nombre-funcion">ft_strcmp</code>.</li>
                                        <li>Si se encuentra una coincidencia, llama a la función `do_..._bonus` correspondiente (ej. <code class="nombre-funcion">do_sa_bonus</code> para "sa\n"). Estas funciones `_bonus` realizan la misma lógica que las originales pero sin llamar a `ft_putstr_fd`.</li>
                                        <li>Si ninguna de las comparaciones es exitosa (la instrucción no es válida), entra en el <code class="concepto-clave">else</code> final y retorna 0.</li>
                                        <li>Si se ejecutó una operación válida, retorna 1.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">ft_strcmp</code>, <code class="nombre-funcion">do_sa_bonus</code>, <code class="nombre-funcion">do_sb_bonus</code>, <code class="nombre-funcion">do_ss_bonus</code>, <code class="nombre-funcion">do_pa_bonus</code>, <code class="nombre-funcion">do_pb_bonus</code>, <code class="nombre-funcion">do_ra_bonus</code>, <code class="nombre-funcion">do_rb_bonus</code>, <code class="nombre-funcion">do_rr_bonus</code>, <code class="nombre-funcion">do_rra_bonus</code>, <code class="nombre-funcion">do_rrb_bonus</code>, <code class="nombre-funcion">do_rrr_bonus</code> (estas funciones `_bonus` se asumen definidas en otros archivos del bonus).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int execute_instruction(t_stacks *stacks, const char *instruction)
            {
                // Compare the input instruction with each valid operation string
                if (ft_strcmp(instruction, "sa\n") == 0)
                    do_sa_bonus(stacks); // Execute sa (bonus version - no print)
                else if (ft_strcmp(instruction, "sb\n") == 0)
                    do_sb_bonus(stacks); // Execute sb (bonus version)
                else if (ft_strcmp(instruction, "ss\n") == 0)
                    do_ss_bonus(stacks); // Execute ss (bonus version)
                else if (ft_strcmp(instruction, "pa\n") == 0)
                    do_pa_bonus(stacks); // Execute pa (bonus version)
                else if (ft_strcmp(instruction, "pb\n") == 0)
                    do_pb_bonus(stacks); // Execute pb (bonus version)
                else if (ft_strcmp(instruction, "ra\n") == 0)
                    do_ra_bonus(stacks); // Execute ra (bonus version)
                else if (ft_strcmp(instruction, "rb\n") == 0)
                    do_rb_bonus(stacks); // Execute rb (bonus version)
                else if (ft_strcmp(instruction, "rr\n") == 0)
                    do_rr_bonus(stacks); // Execute rr (bonus version)
                else if (ft_strcmp(instruction, "rra\n") == 0)
                    do_rra_bonus(stacks); // Execute rra (bonus version)
                else if (ft_strcmp(instruction, "rrb\n") == 0)
                    do_rrb_bonus(stacks); // Execute rrb (bonus version)
                else if (ft_strcmp(instruction, "rrr\n") == 0)
                    do_rrr_bonus(stacks); // Execute rrr (bonus version)
                else // Instruction does not match any valid operation
                    return (0); // Indicate failure (invalid instruction)
            
                // If one of the branches was taken, the instruction was valid
                return (1); // Indicate success
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">cleanup_gnl</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Leer y liberar cualquier línea restante de la entrada estándar usando <code class="nombre-funcion">get_next_line</code>. Esto se usa después de detectar una instrucción inválida para asegurar que el programa no deje datos sin leer en el buffer de entrada.</p>
                                    <h5>Parámetros</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *line</code>: El resultado de la primera llamada a <code class="nombre-funcion">get_next_line</code> después del error (puede ser <code class="nombre-constante">NULL</code> si ya no quedaban líneas).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Entra en un bucle <code class="nombre-constante">while</code> que continúa mientras <code class="nombre-tipo">line</code> no sea <code class="nombre-constante">NULL</code>.</li>
                                        <li>Dentro del bucle, libera la memoria de la línea actual (<code class="nombre-funcion">free(line)</code>).</li>
                                        <li>Llama a <code class="nombre-funcion">get_next_line</code> de nuevo para leer la siguiente línea y actualiza <code class="nombre-tipo">line</code>.</li>
                                        <li>El bucle termina cuando <code class="nombre-funcion">get_next_line</code> devuelve <code class="nombre-constante">NULL</code> (fin de la entrada).</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">free</code>, <code class="nombre-funcion">get_next_line</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static void cleanup_gnl(char *line)
            {
                // Loop as long as get_next_line returns a valid line
                while (line != NULL)
                {
                    free(line); // Free the memory allocated by get_next_line
                    // Read the next line (or NULL if EOF)
                    line = get_next_line(STDIN_FD);
                }
                // All remaining lines (if any) have been read and freed
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">read_and_execute_instructions</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Leer líneas de instrucciones desde la entrada estándar (<code class="nombre-constante">STDIN_FD</code>) una por una, ejecutar cada instrucción válida, y detenerse (retornando error) si se encuentra una instrucción inválida o al llegar al final de la entrada.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal donde se aplicarán las operaciones.</li>
                                    </ul>
                                     <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-constante">1</code>: Si todas las instrucciones leídas fueron válidas y se ejecutaron correctamente hasta el final de la entrada.</li>
                                         <li><code class="nombre-constante">0</code>: Si se encontró una instrucción inválida.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Llama a <code class="nombre-funcion">get_next_line</code> para leer la primera línea de instrucción.</li>
                                        <li>Entra en un bucle <code class="nombre-constante">while</code> que continúa mientras <code class="nombre-tipo">line</code> no sea <code class="nombre-constante">NULL</code> (mientras haya líneas por leer).</li>
                                        <li>Dentro del bucle, llama a <code class="nombre-funcion">execute_instruction</code> pasando <code class="nombre-struct">stacks</code> y la <code class="nombre-tipo">line</code> actual. Guarda el resultado en <code class="nombre-tipo">result</code>.</li>
                                        <li>Si <code class="nombre-tipo">result</code> es 0 (instrucción inválida):
                                            <ul>
                                                <li>Libera la memoria de la línea inválida (<code class="nombre-funcion">free(line)</code>).</li>
                                                <li>Llama a <code class="nombre-funcion">cleanup_gnl</code> pasándole el resultado de una nueva llamada a <code class="nombre-funcion">get_next_line</code> para consumir y liberar el resto de la entrada.</li>
                                                <li>Retorna 0 (error).</li>
                                            </ul>
                                        </li>
                                         <li>Si <code class="nombre-tipo">result</code> es 1 (instrucción válida):
                                            <ul>
                                                <li>Libera la memoria de la línea procesada (<code class="nombre-funcion">free(line)</code>).</li>
                                                <li>Llama a <code class="nombre-funcion">get_next_line</code> para leer la siguiente línea y continuar el bucle.</li>
                                            </ul>
                                        </li>
                                         <li>Si el bucle termina porque <code class="nombre-funcion">get_next_line</code> devolvió <code class="nombre-constante">NULL</code> (fin de la entrada), retorna 1 (éxito).</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">get_next_line</code>, <code class="nombre-funcion">execute_instruction</code>, <code class="nombre-funcion">free</code>, <code class="nombre-funcion">cleanup_gnl</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">int read_and_execute_instructions(t_stacks *stacks)
            {
                char    *line;
                int     result;
            
                // Read the first line of instruction
                line = get_next_line(STDIN_FD);
            
                // Loop while there are lines to read from standard input
                while (line != NULL)
                {
                    // Attempt to execute the instruction read
                    result = execute_instruction(stacks, line);
            
                    // Check if the instruction was invalid
                    if (!result) // execute_instruction returned 0
                    {
                        free(line); // Free the invalid instruction line
                        // Read and discard all remaining lines from input
                        cleanup_gnl(get_next_line(STDIN_FD));
                        return (0); // Return failure (invalid instruction found)
                    }
            
                    // If instruction was valid, free the line and read the next one
                    free(line);
                    line = get_next_line(STDIN_FD);
                }
            
                // If loop finishes (line is NULL), all instructions were valid
                return (1); // Return success
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">bonus/srcs/get_next_line/get_next_line_bonus.c</code> (23/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                            <p class="text-sm text-[var(--color-text-secondary)] mb-4">Implementación de <code class="nombre-funcion">get_next_line</code> para leer una línea desde un file descriptor, manejando múltiples descriptores simultáneamente gracias al array estático <code class="nombre-campo">stash</code>.</p>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">extract_line_from_stash</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Extraer la primera línea completa (hasta el `\n` inclusive, o hasta el final si no hay `\n`) del buffer estático (<code class="nombre-campo">stash</code>).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *stash</code>: El buffer (cadena) que contiene los datos leídos hasta el momento.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *</code>: Una nueva cadena que contiene la línea extraída (incluyendo el `\n` si existe).</li>
                                        <li><code class="nombre-constante">NULL</code>: Si el <code class="nombre-campo">stash</code> es <code class="nombre-constante">NULL</code> o vacío.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-campo">stash</code> es inválido o vacío.</li>
                                        <li>Busca la primera ocurrencia de `\n` en <code class="nombre-campo">stash</code> usando <code class="nombre-funcion">gnl_strchr</code>.</li>
                                        <li>Determina la longitud de la línea: si se encontró `\n`, la longitud es hasta `\n` inclusive; si no, es la longitud total de <code class="nombre-campo">stash</code>.</li>
                                        <li>Crea una subcadena (<code class="nombre-funcion">gnl_substr</code>) desde el inicio de <code class="nombre-campo">stash</code> hasta la longitud calculada.</li>
                                        <li>Retorna la subcadena creada (la línea).</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">gnl_strchr</code>, <code class="nombre-funcion">gnl_strlen</code>, <code class="nombre-funcion">gnl_substr</code> (funciones auxiliares de GNL).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static char *extract_line_from_stash(char *stash)
            {
                char    *line;
                char    *newline_pos;
                size_t  line_len;
            
                // Return NULL if stash is empty or invalid
                if (!stash || *stash == '\0')
                    return (NULL);
            
                // Find the position of the newline character
                newline_pos = gnl_strchr(stash, '\n'); // Assumes gnl_strchr exists
            
                // Calculate the length of the line to extract
                if (newline_pos) // If newline found
                    line_len = (newline_pos - stash) + 1; // Length includes the newline
                else // If no newline found (last line)
                    line_len = gnl_strlen(stash); // Length is the entire remaining stash
            
                // Extract the substring representing the line
                line = gnl_substr(stash, 0, line_len); // Assumes gnl_substr exists
            
                return (line); // Return the extracted line
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">update_stash_after_line</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Actualizar el buffer estático (<code class="nombre-campo">stash</code>) eliminando la línea que acaba de ser extraída, conservando el resto para la próxima llamada a <code class="nombre-funcion">get_next_line</code>. Libera la memoria del antiguo <code class="nombre-campo">stash</code>.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *stash</code>: El buffer actual antes de la actualización.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                     <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *</code>: Un puntero al nuevo <code class="nombre-campo">stash</code> actualizado (la parte restante después de la línea extraída).</li>
                                        <li><code class="nombre-constante">NULL</code>: Si no había `\n` en el <code class="nombre-campo">stash</code> original (lo que significa que todo fue extraído como la última línea) o si no queda nada después del `\n`.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                         <li>Comprueba si <code class="nombre-campo">stash</code> es <code class="nombre-constante">NULL</code>.</li>
                                         <li>Busca la posición del `\n`. Si no se encuentra, significa que todo el <code class="nombre-campo">stash</code> formaba la última línea, así que libera <code class="nombre-campo">stash</code> y retorna <code class="nombre-constante">NULL</code>.</li>
                                         <li>Calcula la posición inicial (<code class="nombre-tipo">start_pos</code>) del resto de la cadena (justo después del `\n`).</li>
                                         <li>Calcula la longitud total del <code class="nombre-campo">stash</code> original.</li>
                                         <li>Si <code class="nombre-tipo">start_pos</code> es mayor o igual que la longitud total (el `\n` era el último carácter), libera <code class="nombre-campo">stash</code> y retorna <code class="nombre-constante">NULL</code> (no queda nada).</li>
                                         <li>Crea una nueva subcadena (<code class="nombre-funcion">gnl_substr</code>) que contiene el resto del <code class="nombre-campo">stash</code> (desde <code class="nombre-tipo">start_pos</code> hasta el final).</li>
                                         <li>Libera la memoria del antiguo <code class="nombre-campo">stash</code>.</li>
                                         <li>Retorna el puntero al nuevo <code class="nombre-campo">stash</code> (<code class="nombre-tipo">new_stash</code>).</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">gnl_strchr</code>, <code class="nombre-funcion">gnl_strlen</code>, <code class="nombre-funcion">gnl_substr</code>, <code class="nombre-funcion">free</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static char *update_stash_after_line(char *stash)
            {
                char    *new_stash;
                char    *newline_pos;
                size_t  stash_len;
                size_t  start_pos;
            
                if (!stash)
                    return (NULL);
            
                // Find the newline character
                newline_pos = gnl_strchr(stash, '\n');
            
                // If no newline was found, the entire stash was the line extracted
                if (!newline_pos)
                {
                    free(stash); // Free the old stash
                    return (NULL); // Nothing remains
                }
            
                // Calculate the starting position of the remaining part (after '\n')
                start_pos = (newline_pos - stash) + 1;
                stash_len = gnl_strlen(stash); // Get the total length
            
                // If the newline was the last character, nothing remains
                if (start_pos >= stash_len)
                {
                    free(stash);
                    return (NULL);
                }
            
                // Create a new substring containing the remainder
                new_stash = gnl_substr(stash, start_pos, stash_len - start_pos);
                free(stash); // Free the old stash
            
                // Return the newly created stash containing the remainder
                return (new_stash);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">read_into_stash</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Leer datos desde el file descriptor (<code class="nombre-tipo">fd</code>) en bloques (<code class="nombre-constante">BUFFER_SIZE</code>) y añadirlos al buffer estático (<code class="nombre-campo">stash</code>) hasta que se encuentre un salto de línea (`\n`) o se alcance el final del archivo (EOF) o ocurra un error de lectura.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int fd</code>: El file descriptor desde donde leer.</li>
                                        <li><code class="nombre-tipo">char *stash</code>: El contenido actual del buffer estático para este <code class="nombre-tipo">fd</code>.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *</code>: Puntero al <code class="nombre-campo">stash</code> actualizado después de la lectura (puede ser el mismo si ya contenía `\n` o si hubo EOF/error).</li>
                                         <li><code class="nombre-constante">NULL</code>: Si ocurre un error de lectura (<code class="nombre-funcion">read</code> devuelve -1) o un error de asignación de memoria en <code class="nombre-funcion">gnl_strjoin_free</code>.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Inicializa <code class="nombre-tipo">bytes_read</code> a 1 para entrar al bucle. Usa <code class="nombre-tipo">temp_stash</code> para trabajar con el <code class="nombre-campo">stash</code>.</li>
                                        <li>Entra en un bucle <code class="nombre-constante">while (bytes_read > 0)</code>.</li>
                                        <li>Dentro del bucle, primero comprueba si ya existe un `\n` en el <code class="nombre-tipo">temp_stash</code> actual. Si es así, significa que ya tenemos una línea completa y no necesitamos leer más, así que rompe el bucle.</li>
                                        <li>Si no hay `\n`, intenta leer <code class="nombre-constante">BUFFER_SIZE</code> bytes desde <code class="nombre-tipo">fd</code> al <code class="nombre-tipo">buffer</code> local.</li>
                                        <li>Si <code class="nombre-funcion">read</code> devuelve -1 (error), libera <code class="nombre-tipo">temp_stash</code> y retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>Si <code class="nombre-funcion">read</code> devuelve 0 (EOF), rompe el bucle (no hay más que leer).</li>
                                        <li>Si se leyeron bytes (<code class="nombre-tipo">bytes_read > 0</code>), añade un terminador nulo al <code class="nombre-tipo">buffer</code>.</li>
                                        <li>Concatena el contenido del <code class="nombre-tipo">buffer</code> al <code class="nombre-tipo">temp_stash</code> actual usando <code class="nombre-funcion">gnl_strjoin_free</code> (que libera el antiguo <code class="nombre-tipo">temp_stash</code> y devuelve la nueva cadena concatenada).</li>
                                        <li>Si <code class="nombre-funcion">gnl_strjoin_free</code> falla, retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>El bucle continúa hasta que se encuentre `\n`, EOF o error.</li>
                                        <li>Retorna el puntero final a <code class="nombre-tipo">temp_stash</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">gnl_strchr</code>, <code class="nombre-funcion">read</code>, <code class="nombre-funcion">free</code>, <code class="nombre-funcion">gnl_strjoin_free</code> (auxiliar de GNL).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static char *read_into_stash(int fd, char *stash)
            {
                char    buffer[BUFFER_SIZE + 1]; // Local buffer for reading
                ssize_t bytes_read;
                char    *temp_stash; // Temporary pointer to work with stash
            
                bytes_read = 1; // Initialize to enter the loop
                temp_stash = stash; // Start with the existing stash content
            
                // Loop as long as read returns positive bytes
                while (bytes_read > 0)
                {
                    // Check if a newline already exists in the current stash
                    if (gnl_strchr(temp_stash, '\n')) // Assumes gnl_strchr exists
                        break ; // If yes, we have a complete line, no need to read more
            
                    // Read data from the file descriptor into the local buffer
                    bytes_read = read(fd, buffer, BUFFER_SIZE);
            
                    // Handle read error
                    if (bytes_read < 0)
                    {
                        free(temp_stash); // Free any previously allocated stash
                        return (NULL); // Return NULL on error
                    }
            
                    // Handle End Of File (EOF)
                    if (bytes_read == 0)
                        break ; // Stop reading if EOF is reached
            
                    // Null-terminate the buffer read
                    buffer[bytes_read] = '\0';
            
                    // Join the newly read buffer content with the existing stash
                    // gnl_strjoin_free should free the old temp_stash and return the new one
                    temp_stash = gnl_strjoin_free(temp_stash, buffer); // Assumes exists
                    if (!temp_stash) // Handle allocation failure in strjoin
                        return (NULL);
                }
                // Return the final stash (potentially updated with new reads)
                return (temp_stash);
            }</code></pre>
                                </div>
                            </details>
            
                             <details class="function-analysis">
                                <summary><code class="nombre-funcion">get_next_line</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Función principal que lee la siguiente línea de un file descriptor (<code class="nombre-tipo">fd</code>). Mantiene un buffer estático (<code class="nombre-campo">stash</code>) separado para cada <code class="nombre-tipo">fd</code> posible (hasta <code class="nombre-constante">OPEN_MAX</code>).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">int fd</code>: El file descriptor desde donde leer.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *</code>: Un puntero a una cadena recién alocada que contiene la siguiente línea leída (incluyendo `\n` si existe).</li>
                                        <li><code class="nombre-constante">NULL</code>: Si no hay más líneas que leer (EOF) o si ocurre un error (en <code class="nombre-tipo">fd</code>, <code class="nombre-constante">BUFFER_SIZE</code>, <code class="nombre-funcion">read</code> o <code class="nombre-funcion">malloc</code>).</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Valida los parámetros de entrada: <code class="nombre-tipo">fd</code> debe ser válido (>= 0 y < <code class="nombre-constante">OPEN_MAX</code>) y <code class="nombre-constante">BUFFER_SIZE</code> debe ser positivo. Si no, retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>Llama a <code class="nombre-funcion">read_into_stash</code> para leer del <code class="nombre-tipo">fd</code> y añadir al buffer estático correspondiente (<code class="nombre-campo">stash[fd]</code>) hasta que se encuentre un `\n` o EOF/error. Actualiza <code class="nombre-campo">stash[fd]</code> con el resultado.</li>
                                        <li>Si <code class="nombre-funcion">read_into_stash</code> retorna <code class="nombre-constante">NULL</code> (error de lectura o malloc), retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>Llama a <code class="nombre-funcion">extract_line_from_stash</code> para obtener la línea completa desde el <code class="nombre-campo">stash[fd]</code> actualizado.</li>
                                        <li>Si <code class="nombre-funcion">extract_line_from_stash</code> retorna <code class="nombre-constante">NULL</code> (el <code class="nombre-campo">stash</code> estaba vacío después de leer, lo cual no debería pasar si <code class="nombre-funcion">read_into_stash</code> no retornó <code class="nombre-constante">NULL</code>, pero se comprueba por seguridad), retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>Llama a <code class="nombre-funcion">update_stash_after_line</code> para eliminar la línea extraída del <code class="nombre-campo">stash[fd]</code> y actualizar <code class="nombre-campo">stash[fd]</code> con el resto.</li>
                                        <li>Retorna la línea (<code class="nombre-tipo">line</code>) extraída.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">read_into_stash</code>, <code class="nombre-funcion">extract_line_from_stash</code>, <code class="nombre-funcion">update_stash_after_line</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">char    *get_next_line(int fd)
            {
                // Static array to hold buffer remnants for each possible file descriptor
                static char *stash[OPEN_MAX]; // OPEN_MAX is a system limit
                char        *line;
            
                // Validate file descriptor and BUFFER_SIZE
                if (fd < 0 || fd >= OPEN_MAX || BUFFER_SIZE <= 0)
                    return (NULL);
            
                // 1. Read from fd into the stash until a newline or EOF/error
                stash[fd] = read_into_stash(fd, stash[fd]);
                if (!stash[fd]) // If read failed or stash is empty after read
                    return (NULL);
            
                // 2. Extract the complete line (up to \n or end) from the stash
                line = extract_line_from_stash(stash[fd]);
                if (!line) // If extraction failed (e.g., stash became NULL unexpectedly)
                {
                    // Although unlikely if read_into_stash succeeded, handle defensively
                     // If stash[fd] exists but line is NULL, it means stash was empty.
                     // We might need to free stash[fd] here if it wasn't freed by update.
                     // However, the current update logic handles freeing.
                    return (NULL);
                }
            
            
                // 3. Update the stash, removing the extracted line and keeping the rest
                stash[fd] = update_stash_after_line(stash[fd]);
            
                // 4. Return the extracted line
                return (line);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">bonus/srcs/get_next_line/get_next_line_utils_bonus.c</code> (24/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                            <p class="text-sm text-[var(--color-text-secondary)] mb-4">Funciones auxiliares de manipulación de cadenas utilizadas por <code class="nombre-funcion">get_next_line</code>.</p>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">gnl_strchr</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Localizar la primera ocurrencia de un carácter (<code class="nombre-tipo">c</code>) en una cadena (<code class="nombre-tipo">s</code>).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">const char *s</code>: La cadena donde buscar.</li>
                                        <li><code class="nombre-tipo">int c</code>: El carácter a buscar (se trata como <code class="nombre-tipo">char</code>).</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *</code>: Un puntero a la primera ocurrencia del carácter <code class="nombre-tipo">c</code> en <code class="nombre-tipo">s</code>.</li>
                                        <li><code class="nombre-constante">NULL</code>: Si la cadena es <code class="nombre-constante">NULL</code> o si el carácter no se encuentra en la cadena (excepto si <code class="nombre-tipo">c</code> es `\0`).</li>
                                        <li>Puntero al terminador nulo: Si <code class="nombre-tipo">c</code> es `\0`.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-tipo">s</code> es <code class="nombre-constante">NULL</code>.</li>
                                        <li>Itera sobre la cadena <code class="nombre-tipo">s</code>.</li>
                                        <li>Si el carácter actual es igual a <code class="nombre-tipo">c</code>, retorna un puntero a esa posición.</li>
                                        <li>Si se llega al final de la cadena (<code class="nombre-constante">'\0'</code>) y <code class="nombre-tipo">c</code> era `\0`, retorna un puntero al terminador nulo.</li>
                                        <li>Si se llega al final y <code class="nombre-tipo">c</code> no era `\0` y no se encontró, retorna <code class="nombre-constante">NULL</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">char    *gnl_strchr(const char *s, int c)
            {
                if (!s) // Handle NULL string input
                    return (NULL);
                while (*s) // Iterate through the string
                {
                    if (*s == (char)c) // If current character matches c
                        return ((char *)s); // Return pointer to the character
                    s++; // Move to the next character
                }
                // Check if the character we were looking for was the null terminator
                if ((char)c == '\0')
                    return ((char *)s); // Return pointer to the null terminator
                // If character not found and it wasn't the null terminator
                return (NULL);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">gnl_strlen</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Calcular la longitud de una cadena de caracteres.</p>
                                     <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-tipo">const char *s</code>: La cadena cuya longitud se quiere calcular.</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-tipo">size_t</code>: La longitud de la cadena (número de caracteres antes del terminador nulo). 0 si la cadena es <code class="nombre-constante">NULL</code>.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Inicializa un contador <code class="nombre-tipo">i</code> a 0.</li>
                                        <li>Comprueba si la cadena <code class="nombre-tipo">s</code> es válida.</li>
                                        <li>Itera mientras el carácter en la posición <code class="nombre-tipo">i</code> no sea el terminador nulo.</li>
                                        <li>Incrementa <code class="nombre-tipo">i</code> en cada iteración.</li>
                                        <li>Retorna el valor final de <code class="nombre-tipo">i</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">size_t  gnl_strlen(const char *s)
            {
                size_t  i;
            
                i = 0;
                // Iterate while string is valid and character at index i is not null terminator
                while (s && s[i])
                    i++;
                return (i); // Return the count
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">perform_join</code> (static)</summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Función auxiliar interna que realiza la concatenación real de dos cadenas (<code class="nombre-tipo">s1</code> y <code class="nombre-tipo">s2</code>) en una nueva cadena alocada, dadas sus longitudes. Libera la memoria de <code class="nombre-tipo">s1</code>.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *s1</code>: La primera cadena (será liberada).</li>
                                        <li><code class="nombre-tipo">char const *s2</code>: La segunda cadena.</li>
                                        <li><code class="nombre-tipo">size_t l1</code>: Longitud de <code class="nombre-tipo">s1</code>.</li>
                                        <li><code class="nombre-tipo">size_t l2</code>: Longitud de <code class="nombre-tipo">s2</code>.</li>
                                    </ul>
                                     <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *</code>: Puntero a la nueva cadena concatenada.</li>
                                        <li><code class="nombre-constante">NULL</code>: Si falla la asignación de memoria para la nueva cadena.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Calcula la memoria necesaria (<code class="nombre-tipo">l1 + l2 + 1</code>) y la aloca usando <code class="nombre-funcion">malloc</code>.</li>
                                        <li>Si <code class="nombre-funcion">malloc</code> falla, libera <code class="nombre-tipo">s1</code> (si existía) y retorna <code class="nombre-constante">NULL</code>.</li>
                                        <li>Copia los caracteres de <code class="nombre-tipo">s1</code> a la nueva cadena (<code class="nombre-tipo">joined</code>).</li>
                                        <li>Copia los caracteres de <code class="nombre-tipo">s2</code> a la nueva cadena, a continuación de los de <code class="nombre-tipo">s1</code>.</li>
                                        <li>Añade el terminador nulo al final de la cadena <code class="nombre-tipo">joined</code>.</li>
                                        <li>Libera la memoria de la cadena original <code class="nombre-tipo">s1</code>.</li>
                                        <li>Retorna el puntero a la nueva cadena <code class="nombre-tipo">joined</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">malloc</code>, <code class="nombre-funcion">free</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">static char *perform_join(char *s1, char const *s2, size_t l1, size_t l2)
            {
                char    *joined;
                size_t  i;
                size_t  j;
            
                // Allocate memory for the new combined string
                joined = (char *)malloc(sizeof(char) * (l1 + l2 + 1));
                if (!joined) // Handle allocation failure
                {
                    free(s1); // Free the first string as per function contract
                    return (NULL);
                }
            
                // Copy characters from s1
                i = 0;
                while (i < l1)
                {
                    joined[i] = s1[i];
                    i++;
                }
            
                // Copy characters from s2
                j = 0;
                while (j < l2)
                {
                    joined[i + j] = s2[j];
                    j++;
                }
            
                // Null-terminate the joined string
                joined[i + j] = '\0';
            
                // Free the original s1 string
                free(s1);
            
                // Return the newly created joined string
                return (joined);
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">gnl_strjoin_free</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Concatenar dos cadenas (<code class="nombre-tipo">s1</code> y <code class="nombre-tipo">s2</code>) creando una nueva cadena. Crucialmente, libera la memoria de la primera cadena (<code class="nombre-tipo">s1</code>) después de la concatenación. Diseñada específicamente para <code class="nombre-funcion">get_next_line</code> donde el <code class="nombre-campo">stash</code> se va reconstruyendo.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-tipo">char *s1</code>: La primera cadena (buffer acumulado, será liberada). Puede ser <code class="nombre-constante">NULL</code> si es la primera vez que se llama.</li>
                                         <li><code class="nombre-tipo">char const *s2</code>: La segunda cadena (nuevo buffer leído).</li>
                                    </ul>
                                    <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *</code>: Puntero a la nueva cadena concatenada.</li>
                                        <li><code class="nombre-constante">NULL</code>: Si falla la asignación de memoria en <code class="nombre-funcion">perform_join</code>.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Calcula la longitud de <code class="nombre-tipo">s1</code> (si no es <code class="nombre-constante">NULL</code>) usando <code class="nombre-funcion">gnl_strlen</code>.</li>
                                        <li>Calcula la longitud de <code class="nombre-tipo">s2</code> usando <code class="nombre-funcion">gnl_strlen</code>.</li>
                                        <li>Llama a la función auxiliar <code class="nombre-funcion">perform_join</code> para realizar la concatenación y la liberación de <code class="nombre-tipo">s1</code>.</li>
                                        <li>Retorna el resultado de <code class="nombre-funcion">perform_join</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">gnl_strlen</code>, <code class="nombre-funcion">perform_join</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">char    *gnl_strjoin_free(char *s1, char const *s2)
            {
                size_t  len1;
                size_t  len2;
            
                len1 = 0;
                if (s1) // Calculate length of s1 only if it exists
                    len1 = gnl_strlen(s1);
                len2 = gnl_strlen(s2); // Calculate length of s2
            
                // Call the helper function to perform the join and free s1
                return (perform_join(s1, s2, len1, len2));
            }</code></pre>
                                </div>
                            </details>
            
                             <details class="function-analysis">
                                <summary><code class="nombre-funcion">gnl_substr</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Extraer una subcadena de una cadena dada (<code class="nombre-tipo">s</code>), empezando desde un índice (<code class="nombre-tipo">start</code>) y con una longitud máxima (<code class="nombre-tipo">len</code>).</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char const *s</code>: La cadena original de la que extraer.</li>
                                        <li><code class="nombre-tipo">unsigned int start</code>: El índice de inicio de la subcadena.</li>
                                         <li><code class="nombre-tipo">size_t len</code>: La longitud máxima de la subcadena a extraer.</li>
                                    </ul>
                                     <h5>Retorno</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">char *</code>: Puntero a la nueva cadena que contiene la subcadena.</li>
                                        <li><code class="nombre-constante">NULL</code>: Si la cadena original <code class="nombre-tipo">s</code> es <code class="nombre-constante">NULL</code> o si falla la asignación de memoria.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si <code class="nombre-tipo">s</code> es <code class="nombre-constante">NULL</code>.</li>
                                        <li>Calcula la longitud de <code class="nombre-tipo">s</code> (<code class="nombre-tipo">s_len</code>).</li>
                                        <li>Ajusta <code class="nombre-tipo">len</code> si es necesario:
                                            <ul>
                                                <li>Si <code class="nombre-tipo">start</code> está fuera de los límites de <code class="nombre-tipo">s</code>, la longitud efectiva es 0.</li>
                                                <li>Si <code class="nombre-tipo">len</code> solicitada excede los caracteres disponibles desde <code class="nombre-tipo">start</code>, se ajusta <code class="nombre-tipo">len</code> a los caracteres realmente disponibles.</li>
                                            </ul>
                                        </li>
                                         <li>Aloca memoria para la subcadena (<code class="nombre-tipo">len + 1</code> para el terminador nulo).</li>
                                         <li>Si <code class="nombre-funcion">malloc</code> falla, retorna <code class="nombre-constante">NULL</code>.</li>
                                         <li>Copia los caracteres desde <code class="nombre-tipo">s[start]</code> a la nueva cadena <code class="nombre-tipo">sub</code>, hasta la longitud ajustada <code class="nombre-tipo">len</code>.</li>
                                         <li>Añade el terminador nulo a <code class="nombre-tipo">sub</code>.</li>
                                         <li>Retorna el puntero a <code class="nombre-tipo">sub</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">gnl_strlen</code>, <code class="nombre-funcion">malloc</code>.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">char    *gnl_substr(char const *s, unsigned int start, size_t len)
            {
                char    *sub;
                size_t  s_len;
                size_t  i;
            
                if (!s) // Handle NULL input string
                    return (NULL);
            
                s_len = gnl_strlen(s); // Get the length of the original string
            
                // Adjust length 'len' based on 'start' and 's_len'
                if (start >= s_len) // If start index is beyond the string
                    len = 0; // Substring length must be 0
                else if (len > s_len - start) // If requested length exceeds available chars
                    len = s_len - start; // Adjust len to the number of available chars
            
                // Allocate memory for the substring (+1 for null terminator)
                sub = (char *)malloc(sizeof(char) * (len + 1));
                if (!sub) // Handle allocation failure
                    return (NULL);
            
                // Copy the characters from 's' starting at 'start' for 'len' characters
                i = 0;
                while (i < len)
                {
                    sub[i] = s[start + i];
                    i++;
                }
                // Null-terminate the new substring
                sub[i] = '\0';
            
                // Return the created substring
                return (sub);
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                    <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
                        <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                            <span><code class="nombre-archivo">bonus/srcs/ops/checker_ops_utils.c</code> (25/28)</span>
                            <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
                        </summary>
                        <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                             <p class="text-sm text-[var(--color-text-secondary)] mb-4">Funciones base para ejecutar las operaciones de push, rotate y reverse rotate, usadas por las funciones <code class="concepto-clave">do_..._bonus</code> del checker.</p>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">push_bonus</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Realizar la operación de "push" genérica (mover nodo superior de <code class="nombre-tipo">src</code> a <code class="nombre-tipo">dest</code>). Esta es la versión interna usada por el checker, idéntica en lógica a la función estática <code class="nombre-funcion">push</code> en <code class="nombre-archivo">ops_push.c</code>.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                         <li><code class="nombre-tipo">t_stack_node **dest</code>: Doble puntero a la cabeza de la pila destino.</li>
                                         <li><code class="nombre-tipo">t_stack_node **src</code>: Doble puntero a la cabeza de la pila fuente.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Llama a <code class="nombre-funcion">detach_top_node_bonus</code> (versión bonus de <code class="nombre-funcion">detach_top_node</code>) para extraer el nodo superior de <code class="nombre-tipo">src</code>.</li>
                                        <li>Si no se extrajo ningún nodo, retorna.</li>
                                        <li>Si la pila <code class="nombre-tipo">dest</code> está vacía, el nodo extraído se convierte en la cabeza.</li>
                                        <li>Si <code class="nombre-tipo">dest</code> no está vacía, inserta el nodo extraído al principio de la lista circular de <code class="nombre-tipo">dest</code>, actualizando los punteros necesarios y la cabeza de <code class="nombre-tipo">dest</code>.</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Llama a: <code class="nombre-funcion">detach_top_node_bonus</code> (asumida, definida en otro archivo del bonus, probablemente <code class="nombre-archivo">checker_ops_push_bonus.c</code> o similar).</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    push_bonus(t_stack_node **dest, t_stack_node **src)
            {
                t_stack_node    *node_to_push;
                t_stack_node    *dest_tail;
            
                // Cannot push from src if src is NULL or empty
                if (!src || !*src)
                    return ;
            
                // 1. Detach the top node from the source stack (bonus version)
                // Assumes detach_top_node_bonus exists and is similar to the mandatory one
                node_to_push = detach_top_node_bonus(src);
                if (!node_to_push) // If source was empty after detach attempt
                    return ;
            
                // 2. Add the detached node to the destination stack
                if (*dest == NULL) // If destination is empty
                {
                    *dest = node_to_push; // Pushed node becomes the only node
                }
                else // If destination is not empty
                {
                    dest_tail = (*dest)->prev; // Get current tail of destination
                    // Insert node_to_push at the beginning
                    dest_tail->next = node_to_push;
                    node_to_push->prev = dest_tail;
                    node_to_push->next = *dest;
                    (*dest)->prev = node_to_push;
                    // Update destination head
                    *dest = node_to_push;
                }
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">rotate_bonus</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Realizar la operación de rotación estándar en una pila. Idéntica en lógica a la función estática <code class="nombre-funcion">rotate</code> en <code class="nombre-archivo">ops_rotate.c</code>.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node **stack</code>: Doble puntero a la cabeza de la pila a rotar.</li>
                                    </ul>
                                    <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si la rotación es posible/necesaria (pila válida, más de un nodo).</li>
                                        <li>Actualiza la cabeza de la pila para que apunte al segundo nodo (<code class="nombre-campo">(*stack)->next</code>).</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    rotate_bonus(t_stack_node **stack)
            {
                // No rotation needed for NULL, empty, or single-node stacks
                if (!stack || !*stack || (*stack)->next == *stack)
                    return ;
                // The new head becomes the current second node
                *stack = (*stack)->next;
            }</code></pre>
                                </div>
                            </details>
            
                            <details class="function-analysis">
                                <summary><code class="nombre-funcion">reverse_rotate_bonus</code></summary>
                                <div>
                                    <h5>Propósito</h5>
                                    <p>Realizar la operación de rotación inversa en una pila. Idéntica en lógica a la función estática <code class="nombre-funcion">reverse_rotate</code> en <code class="nombre-archivo">ops_reverse_rotate.c</code>.</p>
                                    <h5>Parámetros</h5>
                                    <ul class="list-disc list-inside pl-4 text-sm">
                                        <li><code class="nombre-tipo">t_stack_node **stack</code>: Doble puntero a la cabeza de la pila a rotar inversamente.</li>
                                    </ul>
                                     <h5>Lógica</h5>
                                    <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                                        <li>Comprueba si la rotación inversa es posible/necesaria (pila válida, más de un nodo).</li>
                                        <li>Actualiza la cabeza de la pila para que apunte al último nodo (<code class="nombre-campo">(*stack)->prev</code>).</li>
                                    </ol>
                                    <h5>Dependencias</h5>
                                    <p class="text-sm">Ninguna función externa llamada.</p>
                                    <h5>Código</h5>
                                    <pre><code class="language-c">void    reverse_rotate_bonus(t_stack_node **stack)
            {
                // No reverse rotation needed for NULL, empty, or single-node stacks
                if (!stack || !*stack || (*stack)->next == *stack)
                    return ;
                // The new head becomes the current tail (previous node of the current head)
                *stack = (*stack)->prev;
            }</code></pre>
                                </div>
                            </details>
            
                        </div>
                    </details>
                            <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
            <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                <span><code class="nombre-archivo">bonus/srcs/ops/checker_ops_swap_push.c</code> (26/28)</span>
                <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
            </summary>
            <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                 <p class="text-sm text-[var(--color-text-secondary)] mb-4">Implementación de las operaciones <code class="nombre-operacion">sa</code>, <code class="nombre-operacion">sb</code>, <code class="nombre-operacion">ss</code>, <code class="nombre-operacion">pa</code>, y <code class="nombre-operacion">pb</code> para el programa checker (sin impresión de salida).</p>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_sa_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Swap A" (<code class="nombre-operacion">sa</code>) en la <code class="nombre-pila">Pila A</code>, sin imprimir la operación. Versión para el checker.</p>
                        <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                            <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila A</code> tiene al menos 2 elementos.</li>
                            <li>Si es así, llama a <code class="nombre-funcion">swap_bonus</code> (definida en otro lugar, probablemente `checker_ops_utils.c`) pasándole la dirección de la cabeza de A.</li>
                        </ol>
                        <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">swap_bonus</code> (asumida).</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">// Forward declaration (assuming swap_bonus is defined elsewhere)
void    swap_bonus(t_stack_node **stack);

void    do_sa_bonus(t_stacks *stacks)
{
    // Perform swap on A only if possible (size >= 2)
    if (stacks && stacks->size_a >= 2)
        swap_bonus(&(stacks->a)); // Call the bonus swap utility
}</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_sb_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Swap B" (<code class="nombre-operacion">sb</code>) en la <code class="nombre-pila">Pila B</code>, sin imprimir la operación. Versión para el checker.</p>
                        <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                             <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila B</code> tiene al menos 2 elementos.</li>
                             <li>Si es así, llama a <code class="nombre-funcion">swap_bonus</code> pasándole la dirección de la cabeza de B.</li>
                        </ol>
                        <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">swap_bonus</code> (asumida).</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">void    do_sb_bonus(t_stacks *stacks)
{
    // Perform swap on B only if possible (size >= 2)
    if (stacks && stacks->size_b >= 2)
        swap_bonus(&(stacks->b)); // Call the bonus swap utility
}</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_ss_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Swap Both" (<code class="nombre-operacion">ss</code>), realizando <code class="nombre-operacion">sa</code> y <code class="nombre-operacion">sb</code>. Versión para el checker.</p>
                        <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                            <li>Llama a <code class="nombre-funcion">do_sa_bonus</code>.</li>
                            <li>Llama a <code class="nombre-funcion">do_sb_bonus</code>.</li>
                        </ol>
                         <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">do_sa_bonus</code>, <code class="nombre-funcion">do_sb_bonus</code>.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">void    do_ss_bonus(t_stacks *stacks)
{
    // Simply call the individual swap functions for A and B
    do_sa_bonus(stacks);
    do_sb_bonus(stacks);
}</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_pa_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Push A" (<code class="nombre-operacion">pa</code>), moviendo el nodo superior de B a A y actualizando tamaños. Versión para el checker.</p>
                         <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                            <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si B tiene al menos 1 elemento.</li>
                            <li>Llama a <code class="nombre-funcion">push_bonus</code> (definida en `checker_ops_utils.c`) pasando A como destino y B como fuente.</li>
                            <li>Actualiza los tamaños de A (incrementa) y B (decrementa).</li>
                        </ol>
                        <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">push_bonus</code>.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">// Forward declaration (assuming push_bonus is defined elsewhere)
void    push_bonus(t_stack_node **dest, t_stack_node **src);

void    do_pa_bonus(t_stacks *stacks)
{
    // Cannot push from B if B is empty
    if (!stacks || stacks->size_b < 1)
        return ;

    // Perform the push (A is dest, B is src) using the bonus utility
    push_bonus(&(stacks->a), &(stacks->b));

    // Update sizes
    stacks->size_a++;
    stacks->size_b--;
}</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_pb_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Push B" (<code class="nombre-operacion">pb</code>), moviendo el nodo superior de A a B y actualizando tamaños. Versión para el checker.</p>
                         <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                             <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si A tiene al menos 1 elemento.</li>
                             <li>Llama a <code class="nombre-funcion">push_bonus</code> pasando B como destino y A como fuente.</li>
                             <li>Actualiza los tamaños de B (incrementa) y A (decrementa).</li>
                        </ol>
                        <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">push_bonus</code>.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">void    do_pb_bonus(t_stacks *stacks)
{
    // Cannot push from A if A is empty
    if (!stacks || stacks->size_a < 1)
        return ;

    // Perform the push (B is dest, A is src) using the bonus utility
    push_bonus(&(stacks->b), &(stacks->a));

    // Update sizes
    stacks->size_b++;
    stacks->size_a--;
}</code></pre>
                    </div>
                </details>

            </div>
        </details>
                <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
            <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                <span><code class="nombre-archivo">bonus/srcs/ops/checker_ops_rotate.c</code> (27/28)</span>
                <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
            </summary>
            <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                 <p class="text-sm text-[var(--color-text-secondary)] mb-4">Implementación de las operaciones <code class="nombre-operacion">ra</code>, <code class="nombre-operacion">rb</code>, y <code class="nombre-operacion">rr</code> para el programa checker (sin impresión de salida).</p>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_ra_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Rotate A" (<code class="nombre-operacion">ra</code>) en la <code class="nombre-pila">Pila A</code>, sin imprimir la operación. Versión para el checker.</p>
                        <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                            <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila A</code> tiene al menos 2 elementos.</li>
                            <li>Si es así, llama a <code class="nombre-funcion">rotate_bonus</code> (definida en `checker_ops_utils.c`) pasándole la dirección de la cabeza de A.</li>
                        </ol>
                        <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">rotate_bonus</code>.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">// Forward declaration (assuming rotate_bonus is defined elsewhere)
void    rotate_bonus(t_stack_node **stack);

void    do_ra_bonus(t_stacks *stacks)
{
    // Perform rotate on A only if possible (size >= 2)
    if (stacks && stacks->size_a >= 2)
        rotate_bonus(&(stacks->a)); // Call the bonus rotate utility
}</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_rb_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Rotate B" (<code class="nombre-operacion">rb</code>) en la <code class="nombre-pila">Pila B</code>, sin imprimir la operación. Versión para el checker.</p>
                        <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                             <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila B</code> tiene al menos 2 elementos.</li>
                             <li>Si es así, llama a <code class="nombre-funcion">rotate_bonus</code> pasándole la dirección de la cabeza de B.</li>
                        </ol>
                        <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">rotate_bonus</code>.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">void    do_rb_bonus(t_stacks *stacks)
{
    // Perform rotate on B only if possible (size >= 2)
    if (stacks && stacks->size_b >= 2)
        rotate_bonus(&(stacks->b)); // Call the bonus rotate utility
}</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_rr_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Rotate Both" (<code class="nombre-operacion">rr</code>), realizando <code class="nombre-operacion">ra</code> y <code class="nombre-operacion">rb</code>. Versión para el checker.</p>
                        <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                            <li>Llama a <code class="nombre-funcion">do_ra_bonus</code>.</li>
                            <li>Llama a <code class="nombre-funcion">do_rb_bonus</code>.</li>
                        </ol>
                         <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">do_ra_bonus</code>, <code class="nombre-funcion">do_rb_bonus</code>.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">void    do_rr_bonus(t_stacks *stacks)
{
    // Simply call the individual rotate functions for A and B
    do_ra_bonus(stacks);
    do_rb_bonus(stacks);
}</code></pre>
                    </div>
                </details>

            </div>
        </details>
                <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
            <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                <span><code class="nombre-archivo">bonus/srcs/ops/checker_ops_reverse_rotate.c</code> (28/28)</span>
                <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
            </summary>
            <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                 <p class="text-sm text-[var(--color-text-secondary)] mb-4">Implementación de las operaciones <code class="nombre-operacion">rra</code>, <code class="nombre-operacion">rrb</code>, y <code class="nombre-operacion">rrr</code> para el programa checker (sin impresión de salida).</p>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_rra_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Reverse Rotate A" (<code class="nombre-operacion">rra</code>) en la <code class="nombre-pila">Pila A</code>, sin imprimir la operación. Versión para el checker.</p>
                        <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                            <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila A</code> tiene al menos 2 elementos.</li>
                            <li>Si es así, llama a <code class="nombre-funcion">reverse_rotate_bonus</code> (definida en `checker_ops_utils.c`) pasándole la dirección de la cabeza de A.</li>
                        </ol>
                        <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">reverse_rotate_bonus</code>.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">// Forward declaration (assuming reverse_rotate_bonus is defined elsewhere)
void    reverse_rotate_bonus(t_stack_node **stack);

void    do_rra_bonus(t_stacks *stacks)
{
    // Perform reverse rotate on A only if possible (size >= 2)
    if (stacks && stacks->size_a >= 2)
        reverse_rotate_bonus(&(stacks->a)); // Call the bonus reverse rotate utility
}</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_rrb_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Reverse Rotate B" (<code class="nombre-operacion">rrb</code>) en la <code class="nombre-pila">Pila B</code>, sin imprimir la operación. Versión para el checker.</p>
                        <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                             <li>Comprueba si <code class="nombre-struct">stacks</code> es válido y si la <code class="nombre-pila">Pila B</code> tiene al menos 2 elementos.</li>
                             <li>Si es así, llama a <code class="nombre-funcion">reverse_rotate_bonus</code> pasándole la dirección de la cabeza de B.</li>
                        </ol>
                        <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">reverse_rotate_bonus</code>.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">void    do_rrb_bonus(t_stacks *stacks)
{
    // Perform reverse rotate on B only if possible (size >= 2)
    if (stacks && stacks->size_b >= 2)
        reverse_rotate_bonus(&(stacks->b)); // Call the bonus reverse rotate utility
}</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                    <summary><code class="nombre-funcion">do_rrr_bonus</code></summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Ejecutar la operación "Reverse Rotate Both" (<code class="nombre-operacion">rrr</code>), realizando <code class="nombre-operacion">rra</code> y <code class="nombre-operacion">rrb</code>. Versión para el checker.</p>
                        <h5>Parámetros</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stacks *stacks</code>: Puntero a la estructura principal.</li>
                        </ul>
                        <h5>Lógica</h5>
                        <ol class="list-decimal list-inside space-y-2 pl-4 text-sm">
                            <li>Llama a <code class="nombre-funcion">do_rra_bonus</code>.</li>
                            <li>Llama a <code class="nombre-funcion">do_rrb_bonus</code>.</li>
                        </ol>
                         <h5>Dependencias</h5>
                        <p class="text-sm">Llama a: <code class="nombre-funcion">do_rra_bonus</code>, <code class="nombre-funcion">do_rrb_bonus</code>.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">void    do_rrr_bonus(t_stacks *stacks)
{
    // Simply call the individual reverse rotate functions for A and B
    do_rra_bonus(stacks);
    do_rrb_bonus(stacks);
}</code></pre>
                    </div>
                </details>

            </div>
        </details>
                <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
            <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                <span><code class="nombre-archivo">includes/push_swap.h</code> (29/?)</span>
                <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
            </summary>
            <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                 <p class="text-sm text-[var(--color-text-secondary)] mb-4">Archivo de cabecera principal para la parte obligatoria. Define estructuras, constantes e incluye prototipos de funciones y librerías necesarias.</p>

                <details class="function-analysis"> <summary>Guardas de Inclusión</summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Evitar que el contenido del archivo se incluya y procese múltiples veces durante la compilación, lo que causaría errores de redefinición.</p>
                        <h5>Lógica</h5>
                        <p class="text-sm">Se usan las directivas <code>#ifndef PUSH_SWAP_H</code>, <code>#define PUSH_SWAP_H</code> y <code>#endif</code>. La primera vez que se incluye, se define `PUSH_SWAP_H`. Las veces siguientes, `#ifndef` falla y se salta el contenido.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">#ifndef PUSH_SWAP_H
# define PUSH_SWAP_H
// ... contenido ...
#endif</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                     <summary>Inclusiones (`#include`)</summary>
                     <div>
                        <h5>Propósito</h5>
                        <p>Incorporar las definiciones y declaraciones de librerías externas y otros archivos necesarios para compilar el proyecto.</p>
                        <h5>Librerías Incluidas</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code>"../libft/includes/libft.h"</code>: Librería personalizada (funciones `ft_...`).</li>
                            <li><code>&lt;limits.h&gt;</code>: Constantes como `INT_MAX`, `INT_MIN`.</li>
                            <li><code>&lt;stdlib.h&gt;</code>: Funciones como `malloc`, `free`, `exit`.</li>
                            <li><code>&lt;unistd.h&gt;</code>: Funciones como `write`, `read`.</li>
                             <li><code>&lt;stddef.h&gt;</code>: Tipos como `size_t`.</li>
                        </ul>
                        <h5>Código</h5>
                        <pre><code class="language-c"># include "../libft/includes/libft.h"
# include <limits.h>
# include <stdlib.h>
# include <unistd.h>
# include <stddef.h></code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                     <summary>Definiciones de Estructuras</summary>
                     <div>
                        <h5>Propósito</h5>
                        <p>Definir los tipos de datos personalizados que se usarán en todo el proyecto para representar los nodos de la pila y el estado general.</p>
                        <h5>Estructuras</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code class="nombre-struct">t_stack_node</code>: Representa un nodo en la pila (lista doblemente enlazada circular). Contiene <code class="nombre-campo">value</code>, <code class="nombre-campo">index</code>, <code class="nombre-campo">pos</code>, <code class="nombre-campo">target_pos</code>, <code class="nombre-campo">cost_a</code>, <code class="nombre-campo">cost_b</code>, y punteros <code class="nombre-campo">prev</code>/<code class="nombre-campo">next</code>.</li>
                            <li><code class="nombre-struct">t_stacks</code>: Agrupa las dos pilas (<code class="nombre-campo">a</code>, <code class="nombre-campo">b</code>), sus tamaños (<code class="nombre-campo">size_a</code>, <code class="nombre-campo">size_b</code>) y el puntero <code class="nombre-campo">split_args</code> para la gestión de memoria del parsing.</li>
                        </ul>
                         <h5>Código</h5>
                        <pre><code class="language-c">typedef struct s_stack_node { /* ... campos ... */ } t_stack_node;
typedef struct s_stacks { /* ... campos ... */ } t_stacks;
</code></pre>
                    </div>
                </details>

                 <details class="function-analysis">
                     <summary>Constantes Definidas (`#define`)</summary>
                     <div>
                        <h5>Propósito</h5>
                        <p>Definir valores constantes con nombres simbólicos para mejorar la legibilidad y mantenibilidad.</p>
                         <h5>Constantes</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code>ERROR_MSG</code>: Cadena "Error\n".</li>
                            <li><code>STDIN_FD</code>: Descriptor de archivo para entrada estándar (0).</li>
                            <li><code>STDOUT_FD</code>: Descriptor de archivo para salida estándar (1).</li>
                            <li><code>STDERR_FD</code>: Descriptor de archivo para salida de error estándar (2).</li>
                        </ul>
                        <h5>Código</h5>
                        <pre><code class="language-c"># define ERROR_MSG "Error\n"
# define STDIN_FD 0
# define STDOUT_FD 1
# define STDERR_FD 2</code></pre>
                    </div>
                </details>

                 <details class="function-analysis">
                     <summary>Prototipos de Funciones</summary>
                     <div>
                        <h5>Propósito</h5>
                        <p>Declarar las firmas de todas las funciones públicas (no estáticas) definidas en los archivos `.c` del proyecto, permitiendo que se llamen entre sí.</p>
                        <h5>Organización</h5>
                        <p class="text-sm">Los prototipos están agrupados mediante comentarios que indican el archivo `.c` donde se define cada grupo de funciones.</p>
                        <h5>Ejemplo (Extracto)</h5>
                        <pre><code class="language-c">/* utils/errors.c */
void            exit_error(t_stacks *stacks);
void            free_stack(t_stack_node **stack);
/* ... más prototipos ... */
/* sort/sort_cost.c */
void            calculate_cost_to_b(t_stacks *stacks);
/* ... etc ... */</code></pre>
                    </div>
                </details>

            </div>
        </details>
                <details class="border border-[var(--color-border-primary)] rounded-md mb-4">
            <summary class="bg-[var(--color-bg-tertiary)] hover:bg-opacity-80 rounded-t-md p-3 cursor-pointer flex justify-between items-center">
                <span><code class="nombre-archivo">includes/push_swap_bonus.h</code> (30/?)</span>
                <i class="fas fa-chevron-down text-xs text-[var(--color-text-tertiary)] transition-transform duration-200"></i>
            </summary>
            <div class="p-4 bg-[var(--color-bg-secondary)] rounded-b-md">
                 <p class="text-sm text-[var(--color-text-secondary)] mb-4">Archivo de cabecera para la parte bonus (checker). Incluye el header principal, define constantes para GNL y declara los prototipos específicos del checker.</p>

                <details class="function-analysis"> <summary>Guardas de Inclusión</summary>
                    <div>
                        <h5>Propósito</h5>
                        <p>Evitar la inclusión múltiple del contenido de este archivo.</p>
                        <h5>Lógica</h5>
                        <p class="text-sm">Usa <code>#ifndef PUSH_SWAP_BONUS_H</code>, <code>#define PUSH_SWAP_BONUS_H</code> y <code>#endif</code>.</p>
                        <h5>Código</h5>
                        <pre><code class="language-c">#ifndef PUSH_SWAP_BONUS_H
# define PUSH_SWAP_BONUS_H
// ... contenido ...
#endif</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                     <summary>Inclusión Principal (`push_swap.h`)</summary>
                     <div>
                        <h5>Propósito</h5>
                        <p>Incluir todas las definiciones de estructuras (<code class="nombre-struct">t_stack_node</code>, <code class="nombre-struct">t_stacks</code>), constantes (<code class="nombre-constante">ERROR_MSG</code>, etc.) y prototipos de funciones comunes (como las de parsing y manejo de errores) definidas en el archivo de cabecera de la parte obligatoria.</p>
                         <h5>Código</h5>
                        <pre><code class="language-c"># include "push_swap.h"</code></pre>
                    </div>
                </details>

                <details class="function-analysis">
                     <summary>Defines para Get Next Line (GNL)</summary>
                     <div>
                        <h5>Propósito</h5>
                        <p>Definir constantes necesarias para la función <code class="nombre-funcion">get_next_line</code>, si no están ya definidas externamente durante la compilación.</p>
                        <h5>Constantes</h5>
                        <ul class="list-disc list-inside pl-4 text-sm">
                            <li><code>BUFFER_SIZE</code>: Tamaño del buffer de lectura para `read`. Se define a 42 si no existe una definición previa (<code>#ifndef</code>).</li>
                            <li><code>OPEN_MAX</code>: Límite máximo estimado para el número de descriptores de archivo abiertos simultáneamente que GNL puede manejar con su array estático `stash`. Se define a 1024 si no existe.</li>
                        </ul>
                         <h5>Código</h5>
                        <pre><code class="language-c"># ifndef BUFFER_SIZE
#  define BUFFER_SIZE 42
# endif

# ifndef OPEN_MAX
#  define OPEN_MAX 1024 // Commonly used limit, might vary by system
# endif</code></pre>
                    </div>
                </details>

                 <details class="function-analysis">
                     <summary>Prototipos de Funciones (Bonus)</summary>
                     <div>
                        <h5>Propósito</h5>
                        <p>Declarar las firmas de las funciones específicas de la parte bonus (checker), incluyendo GNL, las operaciones `_bonus` y las utilidades del checker.</p>
                        <h5>Organización</h5>
                        <p class="text-sm">Los prototipos están agrupados por el archivo `.c` donde se definen, incluyendo los de GNL y sus utilidades, las operaciones del checker (que no imprimen) y las funciones de lectura/ejecución de instrucciones.</p>
                        <h5>Ejemplo (Extracto)</h5>
                        <pre><code class="language-c">/* bonus/srcs/gnl/get_next_line_bonus.c */
char            *get_next_line(int fd);

/* bonus/srcs/gnl/get_next_line_utils_bonus.c */
char            *gnl_strchr(const char *s, int c);
/* ... GNL utils ... */

/* bonus/srcs/ops/checker_ops_swap_push.c */
void            do_sa_bonus(t_stacks *stacks);
/* ... checker ops ... */

/* bonus/srcs/checker_utils.c */
int             execute_instruction(t_stacks *stacks, const char *instruction);
int             read_and_execute_instructions(t_stacks *stacks);

/* bonus/srcs/ops/checker_ops_utils.c */
/* (No public prototypes as functions are likely static or defined elsewhere) */
</code></pre>
                    </div>
                </details>

            </div>
        </details>
        
                    <div class="task-placeholder mt-8">
                         <p>Análisis del archivo <code class="nombre-archivo">mandatory/srcs/parsing/parsing_utils_helpers.c</code> completado (5/28). El siguiente archivo a analizar sería <code class="nombre-archivo">mandatory/srcs/stack/stack_utils.c</code>.</p>
                    </div>
                </section>

                <section id="tarea-2" class="content-section">
                     <h2 class="border-b-0 pb-0 mb-6">Prueba de Concepto UI/UX (Refinada)</h2>
                    <p class="text-[var(--color-text-secondary)]">
                        Esta sección demuestra los principios de diseño <strong>UI/UX</strong> refinados aplicados a esta documentación. El objetivo es establecer una base visual <strong>premium</strong>, <strong>coherente</strong> y <strong>accesible</strong> antes de profundizar en el contenido técnico.
                    </p>

                    <h3 class="text-lg font-semibold mb-4">Paleta de Colores y Estilo</h3>
                    <p>Se ha implementado una paleta oscura sofisticada utilizando <strong>variables CSS</strong> (simulando <code class="concepto-clave">design tokens</code>) para mayor consistencia y mantenibilidad. Observa cómo se usan variables como <code class="nombre-constante">var(--color-bg-primary)</code> o <code class="nombre-constante">var(--color-accent-primary)</code> en los estilos.</p>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                        <div class="p-4 rounded-md border border-[var(--color-border-primary)]" style="background-color: var(--color-bg-primary);"><span class="block text-xs text-[var(--color-text-tertiary)] mb-1">BG Primary</span><span class="font-medium text-[var(--color-text-primary)]">#0D1117</span></div>
                        <div class="p-4 rounded-md border border-[var(--color-border-primary)]" style="background-color: var(--color-bg-secondary);"><span class="block text-xs text-[var(--color-text-tertiary)] mb-1">BG Secondary</span><span class="font-medium text-[var(--color-text-primary)]">#161B22</span></div>
                        <div class="p-4 rounded-md border border-[var(--color-border-primary)]" style="background-color: var(--color-bg-tertiary);"><span class="block text-xs text-[var(--color-text-tertiary)] mb-1">BG Tertiary</span><span class="font-medium text-[var(--color-text-primary)]">#21262D</span></div>
                        <div class="p-4 rounded-md border border-[var(--color-border-primary)]" style="background-color: var(--color-accent-primary);"><span class="block text-xs text-blue-100 mb-1">Accent</span><span class="font-medium text-white">#58a6ff</span></div>
                    </div>

                    <h3 class="text-lg font-semibold mb-4">Tipografía y Espaciado</h3>
                    <p>Se utiliza la fuente <strong>'Inter'</strong> con una jerarquía clara (definida en los estilos para <code>h1</code>-<code>h6</code>) y espaciado generoso (<code class="nombre-campo">line-height: 1.65</code>, márgenes amplios) para mejorar la legibilidad y crear una sensación de amplitud. La propiedad <code class="nombre-campo">max-width: 75ch</code> en los párrafos limita la longitud de línea para una lectura cómoda.</p>
                    <pre><code class="language-css">/* Ejemplo de estilos base (ver <style> tag) */
body {
    font-family: var(--font-family-sans); /* Fuente 'Inter' */
    background-color: var(--color-bg-primary); /* Fondo principal oscuro */
    color: var(--color-text-secondary); /* Color de texto secundario */
    line-height: 1.65; /* Altura de línea para legibilidad */
}
h2 {
    font-size: 1.75rem; /* Tamaño para encabezados de segundo nivel */
    margin-top: 2.5rem; /* Espacio superior */
    border-bottom: 1px solid var(--color-border-primary); /* Línea separadora */
    /* ... */
}
p {
    margin-bottom: 1.25rem; /* Espacio inferior */
    max-width: 75ch; /* Longitud de línea óptima */
}</code></pre>

                    <h3 class="text-lg font-semibold mb-4 mt-6">Componentes Interactivos</h3>
                    <p>A continuación se muestran ejemplos de componentes clave con sus <strong>estados visuales</strong> definidos (normal, <code>:hover</code>, <code>:focus-visible</code>, <code>:active</code>, <code>:disabled</code>) para proporcionar feedback claro al usuario:</p>

                    <div class="mb-6">
                        <h4 class="font-medium mb-3 text-[var(--color-text-primary)]">Botones</h4>
                        <p>Se definen clases como <code class="nombre-tipo">.button</code>, <code class="nombre-tipo">.button-primary</code>, <code class="nombre-tipo">.button-secondary</code>, <code class="nombre-tipo">.button-destructive</code>.</p>
                        <div class="flex flex-wrap gap-4 items-center mb-4 p-4 border border-[var(--color-border-primary)] rounded-md bg-[var(--color-bg-primary)]">
                            <button class="button button-primary">Primario</button>
                            <button class="button button-primary hover:bg-[var(--color-accent-hover)]">Hover</button>
                            <button class="button button-primary focus-visible:ring">Focus</button>
                            <button class="button button-primary active:bg-[var(--color-accent-active)]">Active</button>
                            <button class="button button-primary" disabled>Disabled</button>
                        </div>
                         <div class="flex flex-wrap gap-4 items-center mb-4 p-4 border border-[var(--color-border-primary)] rounded-md bg-[var(--color-bg-primary)]">
                            <button class="button button-secondary">Secundario</button>
                            <button class="button button-secondary hover:border-[var(--color-border-secondary)] hover:bg-[#2a2f37]">Hover</button>
                            <button class="button button-secondary focus-visible:ring">Focus</button>
                            <button class="button button-secondary active:bg-[#30363d]">Active</button>
                            <button class="button button-secondary" disabled>Disabled</button>
                        </div>
                         <div class="flex flex-wrap gap-4 items-center p-4 border border-[var(--color-border-primary)] rounded-md bg-[var(--color-bg-primary)]">
                            <button class="button button-destructive">Destructivo</button>
                            <button class="button button-destructive hover:bg-[#da3633]">Hover</button>
                            <button class="button button-destructive focus-visible:ring">Focus</button>
                            <button class="button button-destructive active:bg-[#b9251a]">Active</button>
                            <button class="button button-destructive" disabled>Disabled</button>
                        </div>
                    </div>

                    <div class="mb-6">
                        <h4 class="font-medium mb-3 text-[var(--color-text-primary)]">Campo de Entrada</h4>
                        <p>Estilo para elementos <code>&lt;input&gt;</code> con la clase <code class="nombre-tipo">.input-field</code>.</p>
                        <div class="p-4 border border-[var(--color-border-primary)] rounded-md bg-[var(--color-bg-primary)]">
                            <label for="example-input-swapped" class="block text-sm font-medium text-[var(--color-text-secondary)] mb-2">Etiqueta de Ejemplo</label>
                            <input type="text" id="example-input-swapped" class="input-field" placeholder="Escribe algo aquí...">
                            <input type="text" id="example-input-disabled-swapped" class="input-field mt-4" placeholder="Campo deshabilitado" disabled>
                        </div>
                    </div>

                     <div class="mb-6">
                        <h4 class="font-medium mb-3 text-[var(--color-text-primary)]">Sección Colapsable (<code>&lt;details&gt;</code>/<code>&lt;summary&gt;</code>)</h4>
                        <p>Se mejora el estilo por defecto del navegador para los elementos <code>&lt;details&gt;</code> y <code>&lt;summary&gt;</code>, añadiendo un icono de chevron y transiciones.</p>
                        <details>
                            <summary>Haz clic para expandir/colapsar</summary>
                            <div>
                                <p>Este es el contenido detallado. El estilo ha sido mejorado para integrarse con la paleta de colores y ofrecer una mejor experiencia visual. Se utiliza <strong>Font Awesome</strong> para el icono.</p>
                                <pre><code class="language-html">&lt;details&gt;
    &lt;summary&gt;Título&lt;/summary&gt;
    &lt;div&gt;Contenido...&lt;/div&gt;
&lt;/details&gt;</code></pre>
                            </div>
                        </details>
                    </div>

                    <h3 class="text-lg font-semibold mb-4 mt-6">Microinteracciones y Feedback</h3>
                    <p>Se han añadido <strong>transiciones CSS</strong> suaves (<code class="nombre-campo">transition: ... ease</code>) y efectos <code>:hover</code> / <code>:focus-visible</code> / <code>:active</code> a los elementos interactivos para proporcionar <code class="concepto-clave">feedback visual claro</code> y mejorar la sensación de calidad y respuesta de la interfaz.</p>

                    <h3 class="text-lg font-semibold mb-4 mt-6">Accesibilidad (Contraste)</h3>
                    <p>Se ha prestado atención a los <code class="concepto-clave">ratios de contraste</code> entre texto y fondo para cumplir al menos con los criterios <strong>WCAG AA</strong>, asegurando la legibilidad para un mayor número de usuarios, incluyendo aquellos con discapacidades visuales. Por ejemplo, el texto primario (<code class="nombre-constante">--color-text-primary</code>: <code>#e6edf3</code>) sobre el fondo secundario (<code class="nombre-constante">--color-bg-secondary</code>: <code>#161B22</code>) tiene un ratio de contraste alto.</p>
                     <div class="flex space-x-4 text-sm">
                        <span class="p-2 rounded bg-[var(--color-bg-secondary)] text-[var(--color-text-primary)] border border-[var(--color-border-primary)]">Texto Primario sobre Secundario</span>
                        <span class="p-2 rounded bg-[var(--color-accent-primary)] text-[var(--color-accent-text)] border border-[var(--color-accent-primary)]">Texto Blanco sobre Acento</span>
                    </div>
                </section>

                <section id="tarea-5" class="content-section">
                    <h2 class="border-b border-[var(--color-border-primary)] pb-2 mb-4">Tarea 5: Traza de Ejecución Detallada (Ejemplo N=10)</h2>
                    <div class="task-placeholder">
                        <p>Se incluirá una traza detallada con un ejemplo de 10 números, mostrando el estado de las pilas y las operaciones en cada paso significativo.</p>
                    </div>
                </section>

                <section id="tarea-6" class="content-section">
                     <h2 class="border-b border-[var(--color-border-primary)] pb-2 mb-4">Tarea 6: Expansión de Análisis (Ops, Estado, Bonus, Makefile)</h2>
                     <div class="task-placeholder">
                          <p>Se detallarán las operaciones, la gestión del estado, el funcionamiento del <code>checker</code> (bonus) y se analizará el <code>Makefile</code>.</p>
                     </div>
                </section>

                <section id="tarea-7" class="content-section">
                    <h2 class="border-b border-[var(--color-border-primary)] pb-2 mb-4">Tarea 7: Explorador de Código Fuente Mejorado</h2>
                    <div class="task-placeholder">
                        <p>Se organizará y presentará el código fuente completo (<code>.h</code>, <code>.c</code>, <code>Makefile</code>) con comentarios adicionales y análisis de fragmentos clave.</p>
                    </div>
                </section>

                <section id="glosario" class="content-section">
                    <h2 class="border-b border-[var(--color-border-primary)] pb-2 mb-4">Glosario de Términos</h2>
                    <dl class="space-y-4 text-sm">
                        <div>
                            <dt class="font-semibold text-[var(--color-text-primary)]"><code class="nombre-campo">value</code></dt>
                            <dd class="ml-4 text-[var(--color-text-secondary)]">El número entero original proporcionado como entrada.</dd>
                        </div>
                        <div>
                            <dt class="font-semibold text-[var(--color-text-primary)]"><code class="nombre-campo">index</code></dt>
                            <dd class="ml-4 text-[var(--color-text-secondary)]">Un número entero asignado a cada <code class="nombre-campo">value</code>, que representa su posición relativa en el conjunto ordenado (0 para el más pequeño, N-1 para el más grande). Simplifica las comparaciones.</dd>
                        </div>
                        <div>
                            <dt class="font-semibold text-[var(--color-text-primary)]"><code class="nombre-campo">pos</code> (Posición)</dt>
                            <dd class="ml-4 text-[var(--color-text-secondary)]">La posición actual de un nodo dentro de su pila (0 para el nodo superior, 1 para el siguiente, etc.). Cambia dinámicamente con las operaciones.</dd>
                        </div>
                        <div>
                            <dt class="font-semibold text-[var(--color-text-primary)]"><code class="nombre-campo">target_pos</code> (Posición Objetivo)</dt>
                            <dd class="ml-4 text-[var(--color-text-secondary)]">La posición calculada en la pila <em>destino</em> donde un nodo debería ser insertado para mantener el orden relativo de los elementos ya presentes en esa pila destino.</dd>
                        </div>
                        <div>
                            <dt class="font-semibold text-[var(--color-text-primary)]"><code class="nombre-campo">cost_a</code> / <code class="nombre-campo">cost_b</code> (Coste)</dt>
                            <dd class="ml-4 text-[var(--color-text-secondary)]">El número mínimo de operaciones de rotación (<code class="nombre-operacion">ra</code>/<code class="nombre-operacion">rra</code> o <code class="nombre-operacion">rb</code>/<code class="nombre-operacion">rrb</code>) necesarias para llevar un nodo específico (o su posición objetivo) a la cima de la pila correspondiente. Un coste positivo indica rotaciones normales (<code class="nombre-operacion">r</code>), y uno negativo indica rotaciones inversas (<code class="nombre-operacion">rr</code>).</dd>
                        </div>
                         <div>
                            <dt class="font-semibold text-[var(--color-text-primary)]"><code class="concepto-clave">Lista Doblemente Enlazada Circular</code></dt>
                            <dd class="ml-4 text-[var(--color-text-secondary)]">Estructura de datos donde cada nodo apunta al nodo siguiente y al anterior, y el último nodo apunta al primero (y viceversa). Ideal para operaciones de rotación eficientes (O(1)).</dd>
                        </div>
                        <div>
                            <dt class="font-semibold text-[var(--color-text-primary)]"><code class="concepto-clave">Turk Algorithm</code></dt>
                            <dd class="ml-4 text-[var(--color-text-secondary)]">Nombre común (en el contexto de 42) para la heurística de ordenación utilizada en <code class="nombre-archivo">push_swap</code>, que implica mover elementos a la <code class="nombre-pila">Pila B</code> basándose en costes calculados y luego devolverlos ordenadamente a la <code class="nombre-pila">Pila A</code>.</dd>
                        </div>
                         <div>
                            <dt class="font-semibold text-[var(--color-text-primary)]"><code class="concepto-clave">Heurística</code></dt>
                            <dd class="ml-4 text-[var(--color-text-secondary)]">Un enfoque o algoritmo que busca encontrar una buena solución (eficiente, en este caso) a un problema, pero sin garantizar que sea la solución óptima absoluta. Se basa en reglas o cálculos para tomar decisiones "inteligentes" en cada paso.</dd>
                        </div>
                    </dl>
                </section>

                <section id="uso" class="content-section">
                    <h2 class="border-b border-[var(--color-border-primary)] pb-2 mb-4">Cómo Usar</h2>
                    <p>Una vez que tengas el código fuente del proyecto (incluyendo el <code class="nombre-archivo">Makefile</code> y la <code class="nombre-archivo">libft</code>), puedes compilarlo y ejecutarlo desde tu terminal.</p>

                    <h4 class="font-medium mb-2 text-[var(--color-text-primary)]">Compilación</h4>
                    <ul class="list-disc list-inside space-y-1 mb-4 pl-4 text-sm">
                        <li>Para compilar el programa principal <code class="nombre-archivo">push_swap</code>:
                            <pre><code class="language-bash">make</code></pre>
                        </li>
                        <li>Para compilar el verificador <code class="nombre-archivo">checker</code> (parte bonus):
                            <pre><code class="language-bash">make bonus</code></pre>
                        </li>
                         <li>Para limpiar los archivos objeto (<code>.o</code>):
                            <pre><code class="language-bash">make clean</code></pre>
                        </li>
                         <li>Para eliminar los archivos objeto y los ejecutables:
                            <pre><code class="language-bash">make fclean</code></pre>
                        </li>
                         <li>Para recompilar todo desde cero:
                            <pre><code class="language-bash">make re</code></pre>
                        </li>
                    </ul>

                    <h4 class="font-medium mb-2 text-[var(--color-text-primary)]">Ejecución</h4>
                    <p>El programa <code class="nombre-archivo">push_swap</code> toma una lista de números enteros como argumentos y debe imprimir en la salida estándar la secuencia de operaciones más corta que los ordena.</p>
                    <ul class="list-disc list-inside space-y-1 mb-4 pl-4 text-sm">
                        <li><strong>Argumentos múltiples:</strong>
                            <pre><code class="language-bash">./push_swap 4 67 3 8 0 -2</code></pre>
                        </li>
                        <li><strong>Argumento único (string):</strong>
                             <pre><code class="language-bash">./push_swap "4 67 3 8 0 -2"</code></pre>
                        </li>
                    </ul>
                     <p>El verificador <code class="nombre-archivo">checker</code> lee la lista de números iniciales como argumentos y luego lee las operaciones desde la entrada estándar. Al final, imprime "OK" si la pila queda ordenada o "KO" si no.</p>
                     <ul class="list-disc list-inside space-y-1 mb-4 pl-4 text-sm">
                         <li><strong>Uso típico con pipe:</strong>
                             <pre><code class="language-bash">ARG="4 67 3 8 0 -2"; ./push_swap $ARG | ./checker $ARG</code></pre>
                             <p class="text-xs text-[var(--color-text-tertiary)] mt-1">Esto ejecuta <code class="nombre-archivo">push_swap</code>, envía su salida (las operaciones) al <code class="nombre-archivo">checker</code>, que verifica si la secuencia ordena correctamente la lista inicial.</p>
                         </li>
                         <li><strong>Uso interactivo (introduciendo operaciones manualmente):</strong>
                             <pre><code class="language-bash">./checker 4 67 3 8 0 -2
# Escribe operaciones aquí (ej: sa, pb, ra...) y presiona Enter
# Termina con Ctrl+D</code></pre>
                         </li>
                     </ul>
                     <p><strong>Casos de Error:</strong> Si proporcionas argumentos inválidos (no números, duplicados, fuera del rango de <code class="nombre-tipo">int</code>), tanto <code class="nombre-archivo">push_swap</code> como <code class="nombre-archivo">checker</code> deben imprimir "Error" en la salida de error estándar.</p>
                     <pre><code class="language-bash">./push_swap 1 2 3 1 # Error: duplicado
./push_swap 1 2 hola # Error: no es un número
./push_swap 2147483648 # Error: fuera de rango</code></pre>

                </section>

            </main>
        </div>
    </div>
    <footer class="bg-[var(--color-bg-secondary)] text-[var(--color-text-tertiary)] p-6 mt-0 text-center text-sm border-t border-[var(--color-border-primary)]">
        <div class="container mx-auto max-w-6xl">
            Documentación generada para el proyecto Push_Swap. Barcelona, 2025.
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Documentación Push_Swap v1.2 (fix 18 - Tarea 4 stack_utils.c) cargada.'); // Updated version log

            const menuButton = document.getElementById('mobile-menu-button');
            const mobileMenu = document.getElementById('mobile-menu');
            const sidebarNav = document.getElementById('sidebar-nav');
            const sections = document.querySelectorAll('main section[id]'); // Select sections with IDs in main

            // Mobile menu toggle logic
            if (menuButton && mobileMenu) {
                menuButton.addEventListener('click', (event) => {
                   event.stopPropagation();
                   mobileMenu.classList.toggle('hidden');
                });
            }

            // Smooth scrolling for internal links (both header, mobile menu and sidebar)
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetElement = document.querySelector(targetId);
                    if(targetElement) {
                        // Close mobile menu if open before scrolling
                        if (mobileMenu && !mobileMenu.classList.contains('hidden')) {
                           mobileMenu.classList.add('hidden');
                        }

                        const headerOffset = document.querySelector('header').offsetHeight || 64;
                        const elementPosition = targetElement.getBoundingClientRect().top;
                        const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

                        window.scrollTo({
                            top: offsetPosition,
                            behavior: "smooth"
                        });
                    }
                });
            });

             // Close mobile menu if clicking outside of it
             document.addEventListener('click', function(event) {
                if (mobileMenu && !mobileMenu.classList.contains('hidden')) {
                    const isClickInsideMenu = mobileMenu.contains(event.target);
                    const isClickOnButton = menuButton.contains(event.target);
                    if (!isClickInsideMenu && !isClickOnButton) {
                        mobileMenu.classList.add('hidden');
                    }
                }
            });

            // Sidebar active link highlighting on scroll
            const observerOptions = {
              root: null,
              rootMargin: '-64px 0px -50% 0px',
              threshold: 0
            };

            const observer = new IntersectionObserver((entries) => {
              let lastIntersectingLink = null;

              entries.forEach(entry => {
                const id = entry.target.getAttribute('id');
                const sidebarLink = sidebarNav?.querySelector(`a[href="#${id}"]`);

                if (entry.isIntersecting && sidebarLink) {
                     lastIntersectingLink = sidebarLink;
                }
              });

              sidebarNav?.querySelectorAll('a').forEach(link => link.classList.remove('active'));
              if(lastIntersectingLink) {
                  lastIntersectingLink.classList.add('active');
              } else if (window.scrollY < 100 && sidebarNav) { // Highlight first link if near top
                 const firstLink = sidebarNav.querySelector('a');
                 // Check if the first link actually points to the first section
                 if (firstLink && firstLink.getAttribute('href') === `#${sections[0]?.id}`) {
                    firstLink.classList.add('active');
                 }
              }

            }, observerOptions);

            sections.forEach(section => {
              observer.observe(section);
            });

        });
    </script>

</body>
</html>
